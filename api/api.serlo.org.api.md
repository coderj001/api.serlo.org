## API Report File for "@serlo/api.serlo.org"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { A } from 'ts-toolbelt';
import { DocumentNode } from 'graphql';
import { either } from 'fp-ts';
import * as F from 'fp-ts/lib/function';
import { GraphQLResolveInfo } from 'graphql';
import type { GraphQLScalarType } from 'graphql';
import type { GraphQLScalarTypeConfig } from 'graphql';
import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import { O } from 'ts-toolbelt';
import { option } from 'fp-ts';
import { RESTDataSource } from 'apollo-datasource-rest';
import * as t from 'io-ts';
import { default as t_2 } from 'io-ts';

// @public (undocumented)
export type AbstractEntity = {
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    date: Scalars['DateTime'];
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    license: License;
};

// @public (undocumented)
export const AbstractEntityDecoder: t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>;

// @public (undocumented)
export type AbstractEntityResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractEntity'] = ResolversParentTypes['AbstractEntity']> = {
    __resolveType: TypeResolveFn<'Applet' | 'Article' | 'CoursePage' | 'Course' | 'Event' | 'ExerciseGroup' | 'Exercise' | 'GroupedExercise' | 'Solution' | 'Video', ParentType, ContextType>;
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
};

// @public (undocumented)
export type AbstractEntityRevision = {
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    author: User;
    date: Scalars['DateTime'];
    content: Scalars['String'];
    changes: Scalars['String'];
};

// @public (undocumented)
export const AbstractEntityRevisionDecoder: t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>;

// @public (undocumented)
export type AbstractEntityRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractEntityRevision'] = ResolversParentTypes['AbstractEntityRevision']> = {
    __resolveType: TypeResolveFn<'AppletRevision' | 'ArticleRevision' | 'CoursePageRevision' | 'CourseRevision' | 'EventRevision' | 'ExerciseGroupRevision' | 'ExerciseRevision' | 'GroupedExerciseRevision' | 'SolutionRevision' | 'VideoRevision', ParentType, ContextType>;
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

// @public (undocumented)
export type AbstractExercise = {
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    date: Scalars['DateTime'];
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    license: License;
    currentRevision?: Maybe<ExerciseRevision | GroupedExerciseRevision>;
    solution?: Maybe<Solution>;
};

// @public (undocumented)
export const AbstractExerciseDecoder: t.UnionC<[t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Exercise>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    solutionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.GroupedExercise>;
    parentId: t.RefinementC<t.NumberC>;
    solutionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>]>>]>;

// @public (undocumented)
export type AbstractExerciseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractExercise'] = ResolversParentTypes['AbstractExercise']> = {
    __resolveType: TypeResolveFn<'Exercise' | 'GroupedExercise', ParentType, ContextType>;
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['AbstractExerciseRevision']>, ParentType, ContextType>;
    solution?: Resolver<Maybe<ResolversTypes['Solution']>, ParentType, ContextType>;
};

// @public (undocumented)
export type AbstractExerciseRevision = {
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    author: User;
    date: Scalars['DateTime'];
    content: Scalars['String'];
    changes: Scalars['String'];
};

// @public (undocumented)
export type AbstractExerciseRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractExerciseRevision'] = ResolversParentTypes['AbstractExerciseRevision']> = {
    __resolveType: TypeResolveFn<'ExerciseRevision' | 'GroupedExerciseRevision', ParentType, ContextType>;
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

// @public (undocumented)
export type AbstractNavigationChild = {
    navigation?: Maybe<Navigation>;
};

// @public (undocumented)
export type AbstractNavigationChildResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractNavigationChild'] = ResolversParentTypes['AbstractNavigationChild']> = {
    __resolveType: TypeResolveFn<'Page' | 'TaxonomyTerm', ParentType, ContextType>;
    navigation?: Resolver<Maybe<ResolversTypes['Navigation']>, ParentType, ContextType>;
};

// @public (undocumented)
export type AbstractNotificationEvent = {
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
};

// @public (undocumented)
export const AbstractNotificationEventDecoder: t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>;

// @public (undocumented)
export type AbstractNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractNotificationEvent'] = ResolversParentTypes['AbstractNotificationEvent']> = {
    __resolveType: TypeResolveFn<'CheckoutRevisionNotificationEvent' | 'CreateCommentNotificationEvent' | 'CreateEntityLinkNotificationEvent' | 'CreateEntityNotificationEvent' | 'CreateEntityRevisionNotificationEvent' | 'CreateTaxonomyLinkNotificationEvent' | 'CreateTaxonomyTermNotificationEvent' | 'CreateThreadNotificationEvent' | 'RejectRevisionNotificationEvent' | 'RemoveEntityLinkNotificationEvent' | 'RemoveTaxonomyLinkNotificationEvent' | 'SetLicenseNotificationEvent' | 'SetTaxonomyParentNotificationEvent' | 'SetTaxonomyTermNotificationEvent' | 'SetThreadStateNotificationEvent' | 'SetUuidStateNotificationEvent', ParentType, ContextType>;
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
};

// @public (undocumented)
export type AbstractRepository = {
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    instance: Instance;
    license: License;
};

// @public (undocumented)
export type AbstractRepositoryResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractRepository'] = ResolversParentTypes['AbstractRepository']> = {
    __resolveType: TypeResolveFn<'Applet' | 'Article' | 'CoursePage' | 'Course' | 'Event' | 'ExerciseGroup' | 'Exercise' | 'GroupedExercise' | 'Page' | 'Solution' | 'Video', ParentType, ContextType>;
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<AbstractRepositoryThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
};

// @public (undocumented)
export type AbstractRepositoryThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type AbstractRevision = {
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    author: User;
    date: Scalars['DateTime'];
    content: Scalars['String'];
};

// @public (undocumented)
export type AbstractRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractRevision'] = ResolversParentTypes['AbstractRevision']> = {
    __resolveType: TypeResolveFn<'AppletRevision' | 'ArticleRevision' | 'CoursePageRevision' | 'CourseRevision' | 'EventRevision' | 'ExerciseGroupRevision' | 'ExerciseRevision' | 'GroupedExerciseRevision' | 'PageRevision' | 'SolutionRevision' | 'VideoRevision', ParentType, ContextType>;
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<AbstractRevisionThreadsArgs, never>>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

// @public (undocumented)
export type AbstractRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type AbstractTaxonomyTermChild = {
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    instance: Instance;
    license: License;
    taxonomyTerms: TaxonomyTermConnection;
};

// @public (undocumented)
export type AbstractTaxonomyTermChildResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractTaxonomyTermChild'] = ResolversParentTypes['AbstractTaxonomyTermChild']> = {
    __resolveType: TypeResolveFn<'Applet' | 'Article' | 'Course' | 'Event' | 'ExerciseGroup' | 'Exercise' | 'Video', ParentType, ContextType>;
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    taxonomyTerms?: Resolver<ResolversTypes['TaxonomyTermConnection'], ParentType, ContextType, RequireFields<AbstractTaxonomyTermChildTaxonomyTermsArgs, never>>;
};

// @public (undocumented)
export type AbstractTaxonomyTermChildTaxonomyTermsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type AbstractUuid = {
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
};

// @public (undocumented)
export type AbstractUuidConnection = {
    __typename?: 'AbstractUuidConnection';
    edges: Array<AbstractUuidCursor>;
    nodes: Array<Comment | Applet | AppletRevision | Article | ArticleRevision | CoursePage | CoursePageRevision | Course | CourseRevision | Event_2 | EventRevision | ExerciseGroup | ExerciseGroupRevision | Exercise | ExerciseRevision | GroupedExercise | GroupedExerciseRevision | Page | PageRevision | Solution | SolutionRevision | TaxonomyTerm | User | Video | VideoRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type AbstractUuidConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractUuidConnection'] = ResolversParentTypes['AbstractUuidConnection']> = {
    edges?: Resolver<Array<ResolversTypes['AbstractUuidCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['AbstractUuid']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type AbstractUuidCursor = {
    __typename?: 'AbstractUuidCursor';
    cursor: Scalars['String'];
    node: Comment | Applet | AppletRevision | Article | ArticleRevision | CoursePage | CoursePageRevision | Course | CourseRevision | Event_2 | EventRevision | ExerciseGroup | ExerciseGroupRevision | Exercise | ExerciseRevision | GroupedExercise | GroupedExerciseRevision | Page | PageRevision | Solution | SolutionRevision | TaxonomyTerm | User | Video | VideoRevision;
};

// @public (undocumented)
export type AbstractUuidCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractUuidCursor'] = ResolversParentTypes['AbstractUuidCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['AbstractUuid'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const AbstractUuidDecoder: t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>;

// @public (undocumented)
export type AbstractUuidResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AbstractUuid'] = ResolversParentTypes['AbstractUuid']> = {
    __resolveType: TypeResolveFn<'Comment' | 'Applet' | 'AppletRevision' | 'Article' | 'ArticleRevision' | 'CoursePage' | 'CoursePageRevision' | 'Course' | 'CourseRevision' | 'Event' | 'EventRevision' | 'ExerciseGroup' | 'ExerciseGroupRevision' | 'Exercise' | 'ExerciseRevision' | 'GroupedExercise' | 'GroupedExerciseRevision' | 'Page' | 'PageRevision' | 'Solution' | 'SolutionRevision' | 'TaxonomyTerm' | 'User' | 'Video' | 'VideoRevision', ParentType, ContextType>;
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
};

// @public (undocumented)
export function addContext(context: ErrorContext): (error: ErrorEvent_2) => ErrorEvent_2;

// @public (undocumented)
export type AliasInput = {
    instance: Instance;
    path: Scalars['String'];
};

// @public (undocumented)
export type AllPayloads = {
    [M in keyof ModelFactories]: Payloads<ReturnType<ModelFactories[M]>>;
};

// @public (undocumented)
export type Applet = AbstractUuid & AbstractRepository & AbstractEntity & AbstractTaxonomyTermChild & InstanceAware & ThreadAware & {
    __typename?: 'Applet';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    license: License;
    currentRevision?: Maybe<AppletRevision>;
    revisions: AppletRevisionConnection;
    taxonomyTerms: TaxonomyTermConnection;
};

// @public (undocumented)
export const AppletDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Applet>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>;

// @public (undocumented)
export type AppletResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Applet'] = ResolversParentTypes['Applet']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<AppletThreadsArgs, never>>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['AppletRevision']>, ParentType, ContextType>;
    revisions?: Resolver<ResolversTypes['AppletRevisionConnection'], ParentType, ContextType, RequireFields<AppletRevisionsArgs, never>>;
    taxonomyTerms?: Resolver<ResolversTypes['TaxonomyTermConnection'], ParentType, ContextType, RequireFields<AppletTaxonomyTermsArgs, never>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type AppletRevision = AbstractUuid & AbstractRevision & AbstractEntityRevision & ThreadAware & {
    __typename?: 'AppletRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    repository: Applet;
    url: Scalars['String'];
    title: Scalars['String'];
    content: Scalars['String'];
    changes: Scalars['String'];
    metaTitle: Scalars['String'];
    metaDescription: Scalars['String'];
};

// @public (undocumented)
export type AppletRevisionConnection = {
    __typename?: 'AppletRevisionConnection';
    edges: Array<AppletRevisionCursor>;
    nodes: Array<AppletRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type AppletRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AppletRevisionConnection'] = ResolversParentTypes['AppletRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['AppletRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['AppletRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type AppletRevisionCursor = {
    __typename?: 'AppletRevisionCursor';
    cursor: Scalars['String'];
    node: AppletRevision;
};

// @public (undocumented)
export type AppletRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AppletRevisionCursor'] = ResolversParentTypes['AppletRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['AppletRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const AppletRevisionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.AppletRevision>;
    url: t.StringC;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>;

// @public (undocumented)
export type AppletRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['AppletRevision'] = ResolversParentTypes['AppletRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<AppletRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['Applet'], ParentType, ContextType>;
    url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    metaTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    metaDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type AppletRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type AppletRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type AppletTaxonomyTermsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type AppletThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export interface Arguments {
    // (undocumented)
    majorDimension?: MajorDimension;
    // (undocumented)
    range: string;
    // (undocumented)
    spreadsheetId: string;
}

// @public (undocumented)
export type Article = AbstractUuid & AbstractRepository & AbstractEntity & AbstractTaxonomyTermChild & InstanceAware & ThreadAware & {
    __typename?: 'Article';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    license: License;
    currentRevision?: Maybe<ArticleRevision>;
    revisions: ArticleRevisionConnection;
    taxonomyTerms: TaxonomyTermConnection;
};

// @public (undocumented)
export const ArticleDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Article>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>;

// @public (undocumented)
export type ArticleResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Article'] = ResolversParentTypes['Article']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<ArticleThreadsArgs, never>>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['ArticleRevision']>, ParentType, ContextType>;
    revisions?: Resolver<ResolversTypes['ArticleRevisionConnection'], ParentType, ContextType, RequireFields<ArticleRevisionsArgs, never>>;
    taxonomyTerms?: Resolver<ResolversTypes['TaxonomyTermConnection'], ParentType, ContextType, RequireFields<ArticleTaxonomyTermsArgs, never>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ArticleRevision = AbstractUuid & AbstractRevision & AbstractEntityRevision & ThreadAware & {
    __typename?: 'ArticleRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    repository: Article;
    title: Scalars['String'];
    content: Scalars['String'];
    changes: Scalars['String'];
    metaTitle: Scalars['String'];
    metaDescription: Scalars['String'];
};

// @public (undocumented)
export type ArticleRevisionConnection = {
    __typename?: 'ArticleRevisionConnection';
    edges: Array<ArticleRevisionCursor>;
    nodes: Array<ArticleRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type ArticleRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ArticleRevisionConnection'] = ResolversParentTypes['ArticleRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['ArticleRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['ArticleRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ArticleRevisionCursor = {
    __typename?: 'ArticleRevisionCursor';
    cursor: Scalars['String'];
    node: ArticleRevision;
};

// @public (undocumented)
export type ArticleRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ArticleRevisionCursor'] = ResolversParentTypes['ArticleRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['ArticleRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const ArticleRevisionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ArticleRevision>;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>;

// @public (undocumented)
export type ArticleRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ArticleRevision'] = ResolversParentTypes['ArticleRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<ArticleRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['Article'], ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    metaTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    metaDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ArticleRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type ArticleRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type ArticleTaxonomyTermsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type ArticleThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export function assertAll<A, B extends A>(args: {
    assertion: F.Refinement<A, B>;
} & ErrorEvent_2): (list: A[]) => B[];

// @public (undocumented)
export function assertAll<A>(args: {
    assertion: F.Predicate<A>;
} & ErrorEvent_2): (list: A[]) => A[];

// @public (undocumented)
export type AsyncOrSync<T> = Promise<T> | T;

// @public (undocumented)
interface Cache_2 {
    // (undocumented)
    flush(): Promise<void>;
    // (undocumented)
    get<T>({ key }: {
        key: string;
    }): Promise<option.Option<CacheEntry<T>>>;
    // (undocumented)
    quit(): Promise<void>;
    // (undocumented)
    ready(): Promise<void>;
    // (undocumented)
    remove({ key }: {
        key: string;
    }): Promise<void>;
    // (undocumented)
    set<T>(payload: {
        key: string;
        priority?: Priority;
    } & FunctionOrValue<T>): Promise<void>;
}

export { Cache_2 as Cache }

// @public (undocumented)
export interface CacheEntry<Value> {
    // (undocumented)
    lastModified: number;
    // (undocumented)
    value: Value;
}

// @public (undocumented)
export type CellValues = NonEmptyArray<string[]>;

// @public (undocumented)
export type CheckoutRevisionNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'CheckoutRevisionNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    repository: Applet | Article | CoursePage | Course | Event_2 | ExerciseGroup | Exercise | GroupedExercise | Page | Solution | Video;
    revision: AppletRevision | ArticleRevision | CoursePageRevision | CourseRevision | EventRevision | ExerciseGroupRevision | ExerciseRevision | GroupedExerciseRevision | PageRevision | SolutionRevision | VideoRevision;
    reason: Scalars['String'];
};

// @public (undocumented)
export const CheckoutRevisionNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CheckoutRevision>;
    repositoryId: t.RefinementC<t.NumberC>;
    revisionId: t.RefinementC<t.NumberC>;
    reason: t.StringC;
}>]>>;

// @public (undocumented)
export type CheckoutRevisionNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CheckoutRevisionNotificationEvent'] = ResolversParentTypes['CheckoutRevisionNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['AbstractRepository'], ParentType, ContextType>;
    revision?: Resolver<ResolversTypes['AbstractRevision'], ParentType, ContextType>;
    reason?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type Comment = AbstractUuid & {
    __typename?: 'Comment';
    id: Scalars['Int'];
    title: Scalars['String'];
    content: Scalars['String'];
    alias: Scalars['String'];
    trashed: Scalars['Boolean'];
    archived: Scalars['Boolean'];
    createdAt: Scalars['DateTime'];
    author: User;
};

// @public (undocumented)
export type CommentConnection = {
    __typename?: 'CommentConnection';
    edges: Array<CommentEdge>;
    nodes: Array<Comment>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type CommentConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CommentConnection'] = ResolversParentTypes['CommentConnection']> = {
    edges?: Resolver<Array<ResolversTypes['CommentEdge']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['Comment']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const CommentDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<"Comment">;
    authorId: t.NumberC;
    title: t.UnionC<[t.StringC, t.NullC]>;
    date: t.StringC;
    archived: t.BooleanC;
    content: t.StringC;
    parentId: t.RefinementC<t.NumberC>;
    childrenIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>;

// @public (undocumented)
export type CommentEdge = {
    __typename?: 'CommentEdge';
    cursor: Scalars['String'];
    node: Comment;
};

// @public (undocumented)
export type CommentEdgeResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CommentEdge'] = ResolversParentTypes['CommentEdge']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['Comment'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CommentResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Comment'] = ResolversParentTypes['Comment']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    alias?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    archived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export interface Connection<T> {
    // (undocumented)
    edges: Cursor<T>[];
    // (undocumented)
    nodes: T[];
    // (undocumented)
    pageInfo: PageInfo;
    // (undocumented)
    totalCount: number;
}

// @public (undocumented)
export interface ConnectionPayload {
    // (undocumented)
    after?: Maybe<Scalars['String']>;
    // (undocumented)
    before?: Maybe<Scalars['String']>;
    // (undocumented)
    first?: Maybe<Scalars['Int']>;
    // (undocumented)
    last?: Maybe<Scalars['Int']>;
}

// @public (undocumented)
export function consumeErrorEvent<A>(defaultValue: A): (event: ErrorEvent_2) => A;

// @public (undocumented)
export interface Context {
    // (undocumented)
    dataSources: {
        model: ModelDataSource;
    };
    // (undocumented)
    service: Service;
    // (undocumented)
    userId: number | null;
}

// @public (undocumented)
export type Course = AbstractUuid & AbstractRepository & AbstractEntity & AbstractTaxonomyTermChild & InstanceAware & ThreadAware & {
    __typename?: 'Course';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    license: License;
    currentRevision?: Maybe<CourseRevision>;
    revisions: CourseRevisionConnection;
    taxonomyTerms: TaxonomyTermConnection;
    pages: Array<CoursePage>;
};

// @public (undocumented)
export const CourseDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Course>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    pageIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>;

// @public (undocumented)
export type CoursePage = AbstractUuid & AbstractRepository & AbstractEntity & InstanceAware & ThreadAware & {
    __typename?: 'CoursePage';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    license: License;
    currentRevision?: Maybe<CoursePageRevision>;
    revisions: CoursePageRevisionConnection;
    course: Course;
};

// @public (undocumented)
export const CoursePageDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.CoursePage>;
    parentId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type CoursePageResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CoursePage'] = ResolversParentTypes['CoursePage']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<CoursePageThreadsArgs, never>>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['CoursePageRevision']>, ParentType, ContextType>;
    revisions?: Resolver<ResolversTypes['CoursePageRevisionConnection'], ParentType, ContextType, RequireFields<CoursePageRevisionsArgs, never>>;
    course?: Resolver<ResolversTypes['Course'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CoursePageRevision = AbstractUuid & AbstractRevision & AbstractEntityRevision & ThreadAware & {
    __typename?: 'CoursePageRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    repository: CoursePage;
    title: Scalars['String'];
    content: Scalars['String'];
    changes: Scalars['String'];
};

// @public (undocumented)
export type CoursePageRevisionConnection = {
    __typename?: 'CoursePageRevisionConnection';
    edges: Array<CoursePageRevisionCursor>;
    nodes: Array<CoursePageRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type CoursePageRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CoursePageRevisionConnection'] = ResolversParentTypes['CoursePageRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['CoursePageRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['CoursePageRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CoursePageRevisionCursor = {
    __typename?: 'CoursePageRevisionCursor';
    cursor: Scalars['String'];
    node: CoursePageRevision;
};

// @public (undocumented)
export type CoursePageRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CoursePageRevisionCursor'] = ResolversParentTypes['CoursePageRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['CoursePageRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const CoursePageRevisionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.CoursePageRevision>;
    title: t.StringC;
    content: t.StringC;
}>]>>;

// @public (undocumented)
export type CoursePageRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CoursePageRevision'] = ResolversParentTypes['CoursePageRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<CoursePageRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['CoursePage'], ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CoursePageRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type CoursePageRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type CoursePagesArgs = {
    trashed?: Maybe<Scalars['Boolean']>;
    hasCurrentRevision?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type CoursePageThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type CourseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Course'] = ResolversParentTypes['Course']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<CourseThreadsArgs, never>>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['CourseRevision']>, ParentType, ContextType>;
    revisions?: Resolver<ResolversTypes['CourseRevisionConnection'], ParentType, ContextType, RequireFields<CourseRevisionsArgs, never>>;
    taxonomyTerms?: Resolver<ResolversTypes['TaxonomyTermConnection'], ParentType, ContextType, RequireFields<CourseTaxonomyTermsArgs, never>>;
    pages?: Resolver<Array<ResolversTypes['CoursePage']>, ParentType, ContextType, RequireFields<CoursePagesArgs, never>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CourseRevision = AbstractUuid & AbstractRevision & AbstractEntityRevision & ThreadAware & {
    __typename?: 'CourseRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    repository: Course;
    title: Scalars['String'];
    content: Scalars['String'];
    changes: Scalars['String'];
    metaDescription: Scalars['String'];
};

// @public (undocumented)
export type CourseRevisionConnection = {
    __typename?: 'CourseRevisionConnection';
    edges: Array<CourseRevisionCursor>;
    nodes: Array<CourseRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type CourseRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CourseRevisionConnection'] = ResolversParentTypes['CourseRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['CourseRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['CourseRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CourseRevisionCursor = {
    __typename?: 'CourseRevisionCursor';
    cursor: Scalars['String'];
    node: CourseRevision;
};

// @public (undocumented)
export type CourseRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CourseRevisionCursor'] = ResolversParentTypes['CourseRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['CourseRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const CourseRevisionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.CourseRevision>;
    title: t.StringC;
    content: t.StringC;
    metaDescription: t.StringC;
}>]>>;

// @public (undocumented)
export type CourseRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CourseRevision'] = ResolversParentTypes['CourseRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<CourseRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['Course'], ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    metaDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CourseRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type CourseRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type CourseTaxonomyTermsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type CourseThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export function createCache({ timer }: {
    timer: Timer;
}): Cache_2;

// @public (undocumented)
export type CreateCommentNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'CreateCommentNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    thread: UnsupportedThread;
    comment: UnsupportedComment;
};

// @public (undocumented)
export const CreateCommentNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateComment>;
    threadId: t.RefinementC<t.NumberC>;
    commentId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type CreateCommentNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CreateCommentNotificationEvent'] = ResolversParentTypes['CreateCommentNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    thread?: Resolver<ResolversTypes['UnsupportedThread'], ParentType, ContextType>;
    comment?: Resolver<ResolversTypes['UnsupportedComment'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CreateEntityLinkNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'CreateEntityLinkNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    parent: Applet | Article | CoursePage | Course | Event_2 | ExerciseGroup | Exercise | GroupedExercise | Solution | Video;
    child: Applet | Article | CoursePage | Course | Event_2 | ExerciseGroup | Exercise | GroupedExercise | Solution | Video;
};

// @public (undocumented)
export const CreateEntityLinkNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateEntityLink>;
    parentId: t.RefinementC<t.NumberC>;
    childId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type CreateEntityLinkNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CreateEntityLinkNotificationEvent'] = ResolversParentTypes['CreateEntityLinkNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    parent?: Resolver<ResolversTypes['AbstractEntity'], ParentType, ContextType>;
    child?: Resolver<ResolversTypes['AbstractEntity'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CreateEntityNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'CreateEntityNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    entity: Applet | Article | CoursePage | Course | Event_2 | ExerciseGroup | Exercise | GroupedExercise | Solution | Video;
};

// @public (undocumented)
export const CreateEntityNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateEntity>;
    entityId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type CreateEntityNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CreateEntityNotificationEvent'] = ResolversParentTypes['CreateEntityNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    entity?: Resolver<ResolversTypes['AbstractEntity'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CreateEntityRevisionNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'CreateEntityRevisionNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    entity: Applet | Article | CoursePage | Course | Event_2 | ExerciseGroup | Exercise | GroupedExercise | Solution | Video;
    entityRevision: AppletRevision | ArticleRevision | CoursePageRevision | CourseRevision | EventRevision | ExerciseGroupRevision | ExerciseRevision | GroupedExerciseRevision | SolutionRevision | VideoRevision;
};

// @public (undocumented)
export const CreateEntityRevisionNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateEntityRevision>;
    entityId: t.RefinementC<t.NumberC>;
    entityRevisionId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type CreateEntityRevisionNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CreateEntityRevisionNotificationEvent'] = ResolversParentTypes['CreateEntityRevisionNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    entity?: Resolver<ResolversTypes['AbstractEntity'], ParentType, ContextType>;
    entityRevision?: Resolver<ResolversTypes['AbstractEntityRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export function createGoogleSpreadsheetApiModel({ environment, }: {
    environment: Environment;
}): {
    getValues: ModelQuery<Arguments, either.Either<ErrorEvent_2, CellValues>>;
};

// @public (undocumented)
export function createMutationNamespace(): () => {};

// @public (undocumented)
export function createQuery<P, R>(spec: QuerySpec<P, R>, environment: Environment): ModelQuery<P, R>;

// @public (undocumented)
export function createSerloModel({ environment, }: {
    environment: Environment;
}): {
    createThread: ((payload: ThreadCreateThreadInput & {
        userId: number;
    }) => Promise<({
        id: number;
        trashed: boolean;
        alias: string;
    } & {
        __typename: "Comment";
        authorId: number;
        title: string | null;
        date: string;
        archived: boolean;
        content: string;
        parentId: number;
        childrenIds: number[];
    }) | null>) & {
        _mutationSpec: {
            legacyMutate: (payload: ThreadCreateThreadInput & {
                userId: number;
            }) => Promise<({
                id: number;
                trashed: boolean;
                alias: string;
            } & {
                __typename: "Comment";
                authorId: number;
                title: string | null;
                date: string;
                archived: boolean;
                content: string;
                parentId: number;
                childrenIds: number[];
            }) | null>;
        } | {
            decoder: t.Type<({
                id: number;
                trashed: boolean;
                alias: string;
            } & {
                __typename: "Comment";
                authorId: number;
                title: string | null;
                date: string;
                archived: boolean;
                content: string;
                parentId: number;
                childrenIds: number[];
            }) | null, ({
                id: number;
                trashed: boolean;
                alias: string;
            } & {
                __typename: "Comment";
                authorId: number;
                title: string | null;
                date: string;
                archived: boolean;
                content: string;
                parentId: number;
                childrenIds: number[];
            }) | null, unknown>;
            updateCache?: ((payload: ThreadCreateThreadInput & {
                userId: number;
            }, newValue: ({
                id: number;
                trashed: boolean;
                alias: string;
            } & {
                __typename: "Comment";
                authorId: number;
                title: string | null;
                date: string;
                archived: boolean;
                content: string;
                parentId: number;
                childrenIds: number[];
            }) | null) => void | Promise<void>) | undefined;
            mutate: (payload: ThreadCreateThreadInput & {
                userId: number;
            }) => Promise<unknown>;
        };
    };
    archiveThread: ((payload: {
        ids: number[];
        archived: boolean;
        userId: number;
    }) => Promise<void>) & {
        _mutationSpec: {
            legacyMutate: (payload: {
                ids: number[];
                archived: boolean;
                userId: number;
            }) => Promise<void>;
        } | {
            decoder: t.Type<void, void, unknown>;
            updateCache?: ((payload: {
                ids: number[];
                archived: boolean;
                userId: number;
            }, newValue: void) => void | Promise<void>) | undefined;
            mutate: (payload: {
                ids: number[];
                archived: boolean;
                userId: number;
            }) => Promise<unknown>;
        };
    };
    createComment: ((payload: {
        content: string;
        threadId: number;
        userId: number;
        subscribe: boolean;
        sendEmail: boolean;
    }) => Promise<({
        id: number;
        trashed: boolean;
        alias: string;
    } & {
        __typename: "Comment";
        authorId: number;
        title: string | null;
        date: string;
        archived: boolean;
        content: string;
        parentId: number;
        childrenIds: number[];
    }) | null>) & {
        _mutationSpec: {
            legacyMutate: (payload: {
                content: string;
                threadId: number;
                userId: number;
                subscribe: boolean;
                sendEmail: boolean;
            }) => Promise<({
                id: number;
                trashed: boolean;
                alias: string;
            } & {
                __typename: "Comment";
                authorId: number;
                title: string | null;
                date: string;
                archived: boolean;
                content: string;
                parentId: number;
                childrenIds: number[];
            }) | null>;
        } | {
            decoder: t.Type<({
                id: number;
                trashed: boolean;
                alias: string;
            } & {
                __typename: "Comment";
                authorId: number;
                title: string | null;
                date: string;
                archived: boolean;
                content: string;
                parentId: number;
                childrenIds: number[];
            }) | null, ({
                id: number;
                trashed: boolean;
                alias: string;
            } & {
                __typename: "Comment";
                authorId: number;
                title: string | null;
                date: string;
                archived: boolean;
                content: string;
                parentId: number;
                childrenIds: number[];
            }) | null, unknown>;
            updateCache?: ((payload: {
                content: string;
                threadId: number;
                userId: number;
                subscribe: boolean;
                sendEmail: boolean;
            }, newValue: ({
                id: number;
                trashed: boolean;
                alias: string;
            } & {
                __typename: "Comment";
                authorId: number;
                title: string | null;
                date: string;
                archived: boolean;
                content: string;
                parentId: number;
                childrenIds: number[];
            }) | null) => void | Promise<void>) | undefined;
            mutate: (payload: {
                content: string;
                threadId: number;
                userId: number;
                subscribe: boolean;
                sendEmail: boolean;
            }) => Promise<unknown>;
        };
    };
    getActiveAuthorIds: ModelQuery<undefined, number[]>;
    getActiveReviewerIds: ModelQuery<undefined, number[]>;
    getAlias: ModelQuery<{
        path: string;
        instance: Instance;
    }, {
        id: number;
        instance: Instance;
        path: string;
    } | null>;
    getLicense: ModelQuery<{
        id: number;
    }, {
        id: number;
        instance: Instance;
        default: boolean;
        title: string;
        url: string;
        content: string;
        agreement: string;
        iconHref: string;
    }>;
    getNavigationPayload: ModelQuery<{
        instance: Instance;
    }, NavigationPayload>;
    getNavigation: ({ instance, id, }: {
        instance: Instance;
        id: number;
    }) => Promise<NavigationData | null>;
    getNotificationEvent: ModelQuery<{
        id: number;
    }, ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.CheckoutRevision;
        repositoryId: number;
        revisionId: number;
        reason: string;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.CreateComment;
        threadId: number;
        commentId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.CreateEntity;
        entityId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.CreateEntityRevision;
        entityId: number;
        entityRevisionId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.CreateEntityLink;
        parentId: number;
        childId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.CreateTaxonomyTerm;
        taxonomyTermId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.CreateTaxonomyLink;
        parentId: number;
        childId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.CreateThread;
        threadId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.RejectRevision;
        repositoryId: number;
        revisionId: number;
        reason: string;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.RemoveEntityLink;
        parentId: number;
        childId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.RemoveTaxonomyLink;
        parentId: number;
        childId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.SetLicense;
        repositoryId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.SetTaxonomyTerm;
        taxonomyTermId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.SetTaxonomyParent;
        previousParentId: number;
        parentId: number;
        childId: number;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.SetThreadState;
        threadId: number;
        archived: boolean;
    }) | ({
        id: number;
        instance: Instance;
        date: string;
        actorId: number;
        objectId: number;
    } & {
        __typename: NotificationEventType.SetUuidState;
        trashed: boolean;
    }) | null>;
    getNotifications: ModelQuery<{
        userId: number;
    }, {
        notifications: {
            id: number;
            unread: boolean;
            eventId: number;
        }[];
        userId: number;
    }>;
    getSubscriptions: ModelQuery<{
        userId: number;
    }, SubscriptionsPayload>;
    setSubscription: ((payload: {
        ids: number[];
        userId: number;
        subscribe: boolean;
        sendEmail: boolean;
    }) => Promise<void>) & {
        _mutationSpec: {
            legacyMutate: (payload: {
                ids: number[];
                userId: number;
                subscribe: boolean;
                sendEmail: boolean;
            }) => Promise<void>;
        } | {
            decoder: t.Type<void, void, unknown>;
            updateCache?: ((payload: {
                ids: number[];
                userId: number;
                subscribe: boolean;
                sendEmail: boolean;
            }, newValue: void) => void | Promise<void>) | undefined;
            mutate: (payload: {
                ids: number[];
                userId: number;
                subscribe: boolean;
                sendEmail: boolean;
            }) => Promise<unknown>;
        };
    };
    getThreadIds: ModelQuery<{
        id: number;
    }, {
        firstCommentIds: number[];
    }>;
    getUuid: ModelQuery<{
        id: number;
    }, UuidPayload | null>;
    getUuidWithCustomDecoder: <S extends UuidPayload>({ id, decoder, }: {
        id: number;
        decoder: t.Type<S, S, unknown>;
    }) => Promise<S | null>;
    setUuidState: ((payload: {
        ids: number[];
        userId: number;
        trashed: boolean;
    }) => Promise<void>) & {
        _mutationSpec: {
            legacyMutate: (payload: {
                ids: number[];
                userId: number;
                trashed: boolean;
            }) => Promise<void>;
        } | {
            decoder: t.Type<void, void, unknown>;
            updateCache?: ((payload: {
                ids: number[];
                userId: number;
                trashed: boolean;
            }, newValue: void) => void | Promise<void>) | undefined;
            mutate: (payload: {
                ids: number[];
                userId: number;
                trashed: boolean;
            }) => Promise<unknown>;
        };
    };
    removeCacheValue: ((payload: {
        key: string;
    }) => Promise<void>) & {
        _mutationSpec: {
            legacyMutate: (payload: {
                key: string;
            }) => Promise<void>;
        } | {
            decoder: t.Type<void, void, unknown>;
            updateCache?: ((payload: {
                key: string;
            }, newValue: void) => void | Promise<void>) | undefined;
            mutate: (payload: {
                key: string;
            }) => Promise<unknown>;
        };
    };
    setCacheValue: ((payload: {
        key: string;
        value: unknown;
    }) => Promise<void>) & {
        _mutationSpec: {
            legacyMutate: (payload: {
                key: string;
                value: unknown;
            }) => Promise<void>;
        } | {
            decoder: t.Type<void, void, unknown>;
            updateCache?: ((payload: {
                key: string;
                value: unknown;
            }, newValue: void) => void | Promise<void>) | undefined;
            mutate: (payload: {
                key: string;
                value: unknown;
            }) => Promise<unknown>;
        };
    };
    setNotificationState: ((payload: {
        ids: number[];
        userId: number;
        unread: boolean;
    }) => Promise<void>) & {
        _mutationSpec: {
            legacyMutate: (payload: {
                ids: number[];
                userId: number;
                unread: boolean;
            }) => Promise<void>;
        } | {
            decoder: t.Type<void, void, unknown>;
            updateCache?: ((payload: {
                ids: number[];
                userId: number;
                unread: boolean;
            }, newValue: void) => void | Promise<void>) | undefined;
            mutate: (payload: {
                ids: number[];
                userId: number;
                unread: boolean;
            }) => Promise<unknown>;
        };
    };
};

// @public (undocumented)
export function createSwrQueue({ cache, timer, }: {
    cache: Cache_2;
    timer: Timer;
}): SwrQueue;

// @public (undocumented)
export function createSwrQueueWorker({ cache, timer, concurrency, }: {
    cache: Cache_2;
    timer: Timer;
    concurrency: number;
}): {
    ready(): Promise<void>;
    healthy(): Promise<void>;
    quit(): Promise<void>;
    _queue: never;
};

// @public (undocumented)
export type CreateTaxonomyLinkNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'CreateTaxonomyLinkNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    parent: TaxonomyTerm;
    child: Comment | Applet | AppletRevision | Article | ArticleRevision | CoursePage | CoursePageRevision | Course | CourseRevision | Event_2 | EventRevision | ExerciseGroup | ExerciseGroupRevision | Exercise | ExerciseRevision | GroupedExercise | GroupedExerciseRevision | Page | PageRevision | Solution | SolutionRevision | TaxonomyTerm | User | Video | VideoRevision;
};

// @public (undocumented)
export const CreateTaxonomyLinkNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateTaxonomyLink>;
    parentId: t.RefinementC<t.NumberC>;
    childId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type CreateTaxonomyLinkNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CreateTaxonomyLinkNotificationEvent'] = ResolversParentTypes['CreateTaxonomyLinkNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    parent?: Resolver<ResolversTypes['TaxonomyTerm'], ParentType, ContextType>;
    child?: Resolver<ResolversTypes['AbstractUuid'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CreateTaxonomyTermNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'CreateTaxonomyTermNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    taxonomyTerm: TaxonomyTerm;
};

// @public (undocumented)
export const CreateTaxonomyTermNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateTaxonomyTerm>;
    taxonomyTermId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type CreateTaxonomyTermNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CreateTaxonomyTermNotificationEvent'] = ResolversParentTypes['CreateTaxonomyTermNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    taxonomyTerm?: Resolver<ResolversTypes['TaxonomyTerm'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type CreateThreadNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'CreateThreadNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    object: Comment | Applet | AppletRevision | Article | ArticleRevision | CoursePage | CoursePageRevision | Course | CourseRevision | Event_2 | EventRevision | ExerciseGroup | ExerciseGroupRevision | Exercise | ExerciseRevision | GroupedExercise | GroupedExerciseRevision | Page | PageRevision | Solution | SolutionRevision | TaxonomyTerm | User | Video | VideoRevision;
    thread: UnsupportedThread;
};

// @public (undocumented)
export const CreateThreadNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateThread>;
    threadId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type CreateThreadNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['CreateThreadNotificationEvent'] = ResolversParentTypes['CreateThreadNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    object?: Resolver<ResolversTypes['AbstractUuid'], ParentType, ContextType>;
    thread?: Resolver<ResolversTypes['UnsupportedThread'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export function createTimer(): Timer;

// @public (undocumented)
export interface Cursor<T> {
    // (undocumented)
    cursor: string;
    // (undocumented)
    node: T;
}

// @public (undocumented)
export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
    // (undocumented)
    name: 'DateTime';
}

// @public (undocumented)
export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (next: NextResolverFn<TResult>, parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;

// @public (undocumented)
export enum DiscriminatorType {
    // (undocumented)
    Comment = "Comment",
    // (undocumented)
    Page = "Page",
    // (undocumented)
    PageRevision = "PageRevision",
    // (undocumented)
    TaxonomyTerm = "TaxonomyTerm",
    // (undocumented)
    User = "User"
}

// @public (undocumented)
export const emptySwrQueue: SwrQueue;

// @public (undocumented)
export const EntityDecoder: t.UnionC<[t.UnionC<[t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Exercise>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    solutionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.GroupedExercise>;
    parentId: t.RefinementC<t.NumberC>;
    solutionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>]>>]>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Applet>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Article>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Course>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    pageIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.CoursePage>;
    parentId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Event>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.ExerciseGroup>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    exerciseIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Solution>;
    parentId: t.NumberC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Video>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>]>;

// @public (undocumented)
export type EntityPayload = Model<'AbstractEntity'>;

// @public (undocumented)
export const EntityRevisionDecoder: t.UnionC<[t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.AppletRevision>;
    url: t.StringC;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ArticleRevision>;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.CourseRevision>;
    title: t.StringC;
    content: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.CoursePageRevision>;
    title: t.StringC;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.EventRevision>;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ExerciseRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ExerciseGroupRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.GroupedExerciseRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.SolutionRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.VideoRevision>;
    url: t.StringC;
    title: t.StringC;
    content: t.StringC;
}>]>>]>;

// @public (undocumented)
export type EntityRevisionPayload = Model<'AbstractEntityRevision'>;

// @public (undocumented)
export enum EntityRevisionType {
    // (undocumented)
    AppletRevision = "AppletRevision",
    // (undocumented)
    ArticleRevision = "ArticleRevision",
    // (undocumented)
    CoursePageRevision = "CoursePageRevision",
    // (undocumented)
    CourseRevision = "CourseRevision",
    // (undocumented)
    EventRevision = "EventRevision",
    // (undocumented)
    ExerciseGroupRevision = "ExerciseGroupRevision",
    // (undocumented)
    ExerciseRevision = "ExerciseRevision",
    // (undocumented)
    GroupedExerciseRevision = "GroupedExerciseRevision",
    // (undocumented)
    SolutionRevision = "SolutionRevision",
    // (undocumented)
    VideoRevision = "VideoRevision"
}

// @public (undocumented)
export const EntityRevisionTypeDecoder: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;

// @public (undocumented)
export enum EntityType {
    // (undocumented)
    Applet = "Applet",
    // (undocumented)
    Article = "Article",
    // (undocumented)
    Course = "Course",
    // (undocumented)
    CoursePage = "CoursePage",
    // (undocumented)
    Event = "Event",
    // (undocumented)
    Exercise = "Exercise",
    // (undocumented)
    ExerciseGroup = "ExerciseGroup",
    // (undocumented)
    GroupedExercise = "GroupedExercise",
    // (undocumented)
    Solution = "Solution",
    // (undocumented)
    Video = "Video"
}

// @public (undocumented)
export const EntityTypeDecoder: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;

// @public (undocumented)
export interface Environment {
    // (undocumented)
    cache: Cache_2;
    // (undocumented)
    swrQueue: SwrQueue;
}

// @public (undocumented)
export interface ErrorContext {
    // (undocumented)
    errorContext?: Record<string, unknown>;
    // (undocumented)
    location?: string;
    // (undocumented)
    locationContext?: Record<string, unknown>;
}

// @public (undocumented)
interface ErrorEvent_2 extends ErrorContext {
    // (undocumented)
    error: Error;
}

export { ErrorEvent_2 as ErrorEvent }

// @public (undocumented)
type Event_2 = AbstractUuid & AbstractRepository & AbstractEntity & AbstractTaxonomyTermChild & InstanceAware & ThreadAware & {
    __typename?: 'Event';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    license: License;
    currentRevision?: Maybe<EventRevision>;
    revisions: EventRevisionConnection;
    taxonomyTerms: TaxonomyTermConnection;
};

export { Event_2 as Event }

// @public (undocumented)
export const EventDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Event>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>;

// @public (undocumented)
export type EventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Event'] = ResolversParentTypes['Event']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<EventThreadsArgs, never>>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['EventRevision']>, ParentType, ContextType>;
    revisions?: Resolver<ResolversTypes['EventRevisionConnection'], ParentType, ContextType, RequireFields<EventRevisionsArgs, never>>;
    taxonomyTerms?: Resolver<ResolversTypes['TaxonomyTermConnection'], ParentType, ContextType, RequireFields<EventTaxonomyTermsArgs, never>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type EventRevision = AbstractUuid & AbstractRevision & AbstractEntityRevision & ThreadAware & {
    __typename?: 'EventRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    repository: Event_2;
    title: Scalars['String'];
    content: Scalars['String'];
    changes: Scalars['String'];
    metaTitle: Scalars['String'];
    metaDescription: Scalars['String'];
};

// @public (undocumented)
export type EventRevisionConnection = {
    __typename?: 'EventRevisionConnection';
    edges: Array<EventRevisionCursor>;
    nodes: Array<EventRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type EventRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['EventRevisionConnection'] = ResolversParentTypes['EventRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['EventRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['EventRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type EventRevisionCursor = {
    __typename?: 'EventRevisionCursor';
    cursor: Scalars['String'];
    node: EventRevision;
};

// @public (undocumented)
export type EventRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['EventRevisionCursor'] = ResolversParentTypes['EventRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['EventRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const EventRevisionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.EventRevision>;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>;

// @public (undocumented)
export type EventRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['EventRevision'] = ResolversParentTypes['EventRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<EventRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['Event'], ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    metaTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    metaDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type EventRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type EventRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type EventTaxonomyTermsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type EventThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};

// @public (undocumented)
export type Exercise = AbstractUuid & AbstractRepository & AbstractEntity & AbstractTaxonomyTermChild & AbstractExercise & InstanceAware & ThreadAware & {
    __typename?: 'Exercise';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    license: License;
    currentRevision?: Maybe<ExerciseRevision>;
    revisions: ExerciseRevisionConnection;
    taxonomyTerms: TaxonomyTermConnection;
    solution?: Maybe<Solution>;
};

// @public (undocumented)
export const ExerciseDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Exercise>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    solutionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>]>>;

// @public (undocumented)
export type ExerciseGroup = AbstractUuid & AbstractRepository & AbstractEntity & AbstractTaxonomyTermChild & InstanceAware & ThreadAware & {
    __typename?: 'ExerciseGroup';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    license: License;
    currentRevision?: Maybe<ExerciseGroupRevision>;
    revisions: ExerciseGroupRevisionConnection;
    taxonomyTerms: TaxonomyTermConnection;
    exercises: Array<GroupedExercise>;
};

// @public (undocumented)
export const ExerciseGroupDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.ExerciseGroup>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    exerciseIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>;

// @public (undocumented)
export type ExerciseGroupResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ExerciseGroup'] = ResolversParentTypes['ExerciseGroup']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<ExerciseGroupThreadsArgs, never>>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['ExerciseGroupRevision']>, ParentType, ContextType>;
    revisions?: Resolver<ResolversTypes['ExerciseGroupRevisionConnection'], ParentType, ContextType, RequireFields<ExerciseGroupRevisionsArgs, never>>;
    taxonomyTerms?: Resolver<ResolversTypes['TaxonomyTermConnection'], ParentType, ContextType, RequireFields<ExerciseGroupTaxonomyTermsArgs, never>>;
    exercises?: Resolver<Array<ResolversTypes['GroupedExercise']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ExerciseGroupRevision = AbstractUuid & AbstractRevision & AbstractEntityRevision & ThreadAware & {
    __typename?: 'ExerciseGroupRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    repository: ExerciseGroup;
    content: Scalars['String'];
    changes: Scalars['String'];
};

// @public (undocumented)
export type ExerciseGroupRevisionConnection = {
    __typename?: 'ExerciseGroupRevisionConnection';
    edges: Array<ExerciseGroupRevisionCursor>;
    nodes: Array<ExerciseGroupRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type ExerciseGroupRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ExerciseGroupRevisionConnection'] = ResolversParentTypes['ExerciseGroupRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['ExerciseGroupRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['ExerciseGroupRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ExerciseGroupRevisionCursor = {
    __typename?: 'ExerciseGroupRevisionCursor';
    cursor: Scalars['String'];
    node: ExerciseGroupRevision;
};

// @public (undocumented)
export type ExerciseGroupRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ExerciseGroupRevisionCursor'] = ResolversParentTypes['ExerciseGroupRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['ExerciseGroupRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const ExerciseGroupRevisionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ExerciseGroupRevision>;
    content: t.StringC;
}>]>>;

// @public (undocumented)
export type ExerciseGroupRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ExerciseGroupRevision'] = ResolversParentTypes['ExerciseGroupRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<ExerciseGroupRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['ExerciseGroup'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ExerciseGroupRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type ExerciseGroupRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type ExerciseGroupTaxonomyTermsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type ExerciseGroupThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type ExerciseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Exercise'] = ResolversParentTypes['Exercise']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<ExerciseThreadsArgs, never>>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['ExerciseRevision']>, ParentType, ContextType>;
    revisions?: Resolver<ResolversTypes['ExerciseRevisionConnection'], ParentType, ContextType, RequireFields<ExerciseRevisionsArgs, never>>;
    taxonomyTerms?: Resolver<ResolversTypes['TaxonomyTermConnection'], ParentType, ContextType, RequireFields<ExerciseTaxonomyTermsArgs, never>>;
    solution?: Resolver<Maybe<ResolversTypes['Solution']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ExerciseRevision = AbstractUuid & AbstractRevision & AbstractEntityRevision & AbstractExerciseRevision & ThreadAware & {
    __typename?: 'ExerciseRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    repository: Exercise;
    content: Scalars['String'];
    changes: Scalars['String'];
};

// @public (undocumented)
export type ExerciseRevisionConnection = {
    __typename?: 'ExerciseRevisionConnection';
    edges: Array<ExerciseRevisionCursor>;
    nodes: Array<ExerciseRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type ExerciseRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ExerciseRevisionConnection'] = ResolversParentTypes['ExerciseRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['ExerciseRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['ExerciseRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ExerciseRevisionCursor = {
    __typename?: 'ExerciseRevisionCursor';
    cursor: Scalars['String'];
    node: ExerciseRevision;
};

// @public (undocumented)
export type ExerciseRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ExerciseRevisionCursor'] = ResolversParentTypes['ExerciseRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['ExerciseRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const ExerciseRevisionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ExerciseRevision>;
    content: t.StringC;
}>]>>;

// @public (undocumented)
export type ExerciseRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ExerciseRevision'] = ResolversParentTypes['ExerciseRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<ExerciseRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['Exercise'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ExerciseRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type ExerciseRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type ExerciseTaxonomyTermsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type ExerciseThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type FunctionOrValue<T> = UpdateFunction<T> | {
    value: T;
};

// @public (undocumented)
export type GetResolver<Name extends keyof Resolvers> = NonNullable<Resolvers[Name]>;

// @public (undocumented)
export type GroupedExercise = AbstractUuid & AbstractRepository & AbstractEntity & AbstractExercise & InstanceAware & ThreadAware & {
    __typename?: 'GroupedExercise';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    license: License;
    currentRevision?: Maybe<GroupedExerciseRevision>;
    revisions: GroupedExerciseRevisionConnection;
    solution?: Maybe<Solution>;
    exerciseGroup: ExerciseGroup;
};

// @public (undocumented)
export const GroupedExerciseDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.GroupedExercise>;
    parentId: t.RefinementC<t.NumberC>;
    solutionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>]>>;

// @public (undocumented)
export type GroupedExerciseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['GroupedExercise'] = ResolversParentTypes['GroupedExercise']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<GroupedExerciseThreadsArgs, never>>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['GroupedExerciseRevision']>, ParentType, ContextType>;
    revisions?: Resolver<ResolversTypes['GroupedExerciseRevisionConnection'], ParentType, ContextType, RequireFields<GroupedExerciseRevisionsArgs, never>>;
    solution?: Resolver<Maybe<ResolversTypes['Solution']>, ParentType, ContextType>;
    exerciseGroup?: Resolver<ResolversTypes['ExerciseGroup'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type GroupedExerciseRevision = AbstractUuid & AbstractRevision & AbstractEntityRevision & AbstractExerciseRevision & ThreadAware & {
    __typename?: 'GroupedExerciseRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    repository: GroupedExercise;
    content: Scalars['String'];
    changes: Scalars['String'];
};

// @public (undocumented)
export type GroupedExerciseRevisionConnection = {
    __typename?: 'GroupedExerciseRevisionConnection';
    edges: Array<GroupedExerciseRevisionCursor>;
    nodes: Array<GroupedExerciseRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type GroupedExerciseRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['GroupedExerciseRevisionConnection'] = ResolversParentTypes['GroupedExerciseRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['GroupedExerciseRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['GroupedExerciseRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type GroupedExerciseRevisionCursor = {
    __typename?: 'GroupedExerciseRevisionCursor';
    cursor: Scalars['String'];
    node: GroupedExerciseRevision;
};

// @public (undocumented)
export type GroupedExerciseRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['GroupedExerciseRevisionCursor'] = ResolversParentTypes['GroupedExerciseRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['GroupedExerciseRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const GroupedExerciseRevisionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.GroupedExerciseRevision>;
    content: t.StringC;
}>]>>;

// @public (undocumented)
export type GroupedExerciseRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['GroupedExerciseRevision'] = ResolversParentTypes['GroupedExerciseRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<GroupedExerciseRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['GroupedExercise'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type GroupedExerciseRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type GroupedExerciseRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type GroupedExerciseThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export enum Instance {
    // (undocumented)
    De = "de",
    // (undocumented)
    En = "en",
    // (undocumented)
    Es = "es",
    // (undocumented)
    Fr = "fr",
    // (undocumented)
    Hi = "hi",
    // (undocumented)
    Ta = "ta"
}

// @public (undocumented)
export type InstanceAware = {
    instance: Instance;
};

// @public (undocumented)
export type InstanceAwareResolvers<ContextType = Context, ParentType extends ResolversParentTypes['InstanceAware'] = ResolversParentTypes['InstanceAware']> = {
    __resolveType: TypeResolveFn<'CheckoutRevisionNotificationEvent' | 'CreateCommentNotificationEvent' | 'CreateEntityLinkNotificationEvent' | 'CreateEntityNotificationEvent' | 'CreateEntityRevisionNotificationEvent' | 'CreateTaxonomyLinkNotificationEvent' | 'CreateTaxonomyTermNotificationEvent' | 'CreateThreadNotificationEvent' | 'RejectRevisionNotificationEvent' | 'RemoveEntityLinkNotificationEvent' | 'RemoveTaxonomyLinkNotificationEvent' | 'SetLicenseNotificationEvent' | 'SetTaxonomyParentNotificationEvent' | 'SetTaxonomyTermNotificationEvent' | 'SetThreadStateNotificationEvent' | 'SetUuidStateNotificationEvent' | 'Applet' | 'Article' | 'CoursePage' | 'Course' | 'Event' | 'ExerciseGroup' | 'Exercise' | 'GroupedExercise' | 'Page' | 'Solution' | 'TaxonomyTerm' | 'Video', ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
};

// @public (undocumented)
export const InstanceDecoder: t.Type<Instance>;

// @public
export type InterfaceResolvers<I extends keyof Resolvers> = Required<Pick<Resolvers, I>>;

// @public @deprecated (undocumented)
export type IResolvers<ContextType = Context> = Resolvers<ContextType>;

// @public (undocumented)
export function isDefined<A>(value?: A | null): value is A;

// @public (undocumented)
export function isQuery(query: unknown): query is ModelQuery<unknown, unknown>;

// @public (undocumented)
export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

// @public (undocumented)
export interface JsonObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONObject'], any> {
    // (undocumented)
    name: 'JSONObject';
}

// @public (undocumented)
export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    // (undocumented)
    name: 'JSON';
}

// @public (undocumented)
export type LegacyResolver<P, A, T> = (parent: P, args: A, context: Context, info: GraphQLResolveInfo) => AsyncOrSync<T>;

// @public (undocumented)
export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

// @public (undocumented)
export type License = {
    __typename?: 'License';
    id: Scalars['Int'];
    instance: Instance;
    default: Scalars['Boolean'];
    title: Scalars['String'];
    url: Scalars['String'];
    content: Scalars['String'];
    agreement: Scalars['String'];
    iconHref: Scalars['String'];
};

// @public (undocumented)
export type LicenseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['License'] = ResolversParentTypes['License']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    default?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    agreement?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    iconHref?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export enum MajorDimension {
    // (undocumented)
    Columns = "COLUMNS",
    // (undocumented)
    Rows = "ROWS"
}

// @public (undocumented)
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};

// @public (undocumented)
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};

// @public (undocumented)
export type Maybe<T> = T | null;

// @public (undocumented)
export function mergeSchemas(...schemas: Schema[]): Schema;

// @public
export type Model<M extends keyof ModelMapping> = NonNullable<ModelMapping[M]>;

// @public (undocumented)
export class ModelDataSource extends RESTDataSource {
    constructor(environment: Environment);
    // (undocumented)
    googleSpreadsheetApi: ReturnType<typeof createGoogleSpreadsheetApiModel>;
    // (undocumented)
    serlo: ReturnType<typeof createSerloModel>;
    // (undocumented)
    updateCacheValue({ key }: {
        key: string;
    }): Promise<void>;
}

// @public (undocumented)
export type ModelFactories = typeof modelFactories;

// @public (undocumented)
export const modelFactories: {
    googleSpreadsheetApi: typeof createGoogleSpreadsheetApiModel;
    serlo: typeof createSerloModel;
};

// @public
export type ModelMapping = {
    [R in keyof Resolvers]: '__resolveType' extends keyof GetResolver<R> ? GetResolver<R>['__resolveType'] extends (...args: infer P) => unknown ? P[0] : never : '__isTypeOf' extends keyof GetResolver<R> ? NonNullable<GetResolver<R>['__isTypeOf']> extends (...args: infer P) => unknown ? P[0] : never : never;
};

// @public (undocumented)
export type ModelOf<T> = A.Equals<T, unknown> extends 1 ? T : T extends boolean | string | number | null ? T : Typename<T> extends keyof Models ? Models[Typename<T>] : T extends {
    nodes: Array<infer U>;
    totalCount: number;
} ? Connection<ModelOf<U>> : T extends (infer U)[] ? ModelOf<U>[] : T extends object ? {
    [P in keyof T]: ModelOf<T[P]>;
} : never;

// @public (undocumented)
export type ModelQuery<P, R> = (P extends undefined ? () => Promise<R> : (payload: P) => Promise<R>) & {
    _querySpec: QuerySpecWithHelpers<P, R>;
};

// @public (undocumented)
export interface Models {
    // (undocumented)
    Applet: t.TypeOf<typeof AppletDecoder>;
    // (undocumented)
    AppletRevision: t.TypeOf<typeof AppletRevisionDecoder>;
    // (undocumented)
    Article: t.TypeOf<typeof ArticleDecoder>;
    // (undocumented)
    ArticleRevision: t.TypeOf<typeof ArticleRevisionDecoder>;
    // (undocumented)
    CheckoutRevisionNotificationEvent: t.TypeOf<typeof CheckoutRevisionNotificationEventDecoder>;
    // (undocumented)
    Comment: t.TypeOf<typeof CommentDecoder>;
    // (undocumented)
    Course: t.TypeOf<typeof CourseDecoder>;
    // (undocumented)
    CoursePage: t.TypeOf<typeof CoursePageDecoder>;
    // (undocumented)
    CoursePageRevision: t.TypeOf<typeof CoursePageRevisionDecoder>;
    // (undocumented)
    CourseRevision: t.TypeOf<typeof CourseRevisionDecoder>;
    // (undocumented)
    CreateCommentNotificationEvent: t.TypeOf<typeof CreateCommentNotificationEventDecoder>;
    // (undocumented)
    CreateEntityLinkNotificationEvent: t.TypeOf<typeof CreateEntityLinkNotificationEventDecoder>;
    // (undocumented)
    CreateEntityNotificationEvent: t.TypeOf<typeof CreateEntityNotificationEventDecoder>;
    // (undocumented)
    CreateEntityRevisionNotificationEvent: t.TypeOf<typeof CreateEntityRevisionNotificationEventDecoder>;
    // (undocumented)
    CreateTaxonomyLinkNotificationEvent: t.TypeOf<typeof CreateTaxonomyLinkNotificationEventDecoder>;
    // (undocumented)
    CreateTaxonomyTermNotificationEvent: t.TypeOf<typeof CreateTaxonomyTermNotificationEventDecoder>;
    // (undocumented)
    CreateThreadNotificationEvent: t.TypeOf<typeof CreateThreadNotificationEventDecoder>;
    // (undocumented)
    Event: t.TypeOf<typeof EventDecoder>;
    // (undocumented)
    EventRevision: t.TypeOf<typeof EventRevisionDecoder>;
    // (undocumented)
    Exercise: t.TypeOf<typeof ExerciseDecoder>;
    // (undocumented)
    ExerciseGroup: t.TypeOf<typeof ExerciseGroupDecoder>;
    // (undocumented)
    ExerciseGroupRevision: t.TypeOf<typeof ExerciseGroupRevisionDecoder>;
    // (undocumented)
    ExerciseRevision: t.TypeOf<typeof ExerciseRevisionDecoder>;
    // (undocumented)
    GroupedExercise: t.TypeOf<typeof GroupedExerciseDecoder>;
    // (undocumented)
    GroupedExerciseRevision: t.TypeOf<typeof GroupedExerciseRevisionDecoder>;
    // (undocumented)
    License: Payload<'serlo', 'getLicense'>;
    // (undocumented)
    Mutation: Record<string, never>;
    // (undocumented)
    Navigation: Payload<'serlo', 'getNavigation'>;
    // (undocumented)
    Notification: t.TypeOf<typeof NotificationDecoder>;
    // (undocumented)
    Page: t.TypeOf<typeof PageDecoder>;
    // (undocumented)
    PageRevision: t.TypeOf<typeof PageRevisionDecoder>;
    // (undocumented)
    Query: Record<string, never>;
    // (undocumented)
    RejectRevisionNotificationEvent: t.TypeOf<typeof RejectRevisionNotificationEventDecoder>;
    // (undocumented)
    RemoveEntityLinkNotificationEvent: t.TypeOf<typeof RemoveEntityLinkNotificationEventDecoder>;
    // (undocumented)
    RemoveTaxonomyLinkNotificationEvent: t.TypeOf<typeof RemoveTaxonomyLinkNotificationEventDecoder>;
    // (undocumented)
    ScopedRole: {
        role: Role;
        scope: Scope;
    };
    // (undocumented)
    SetLicenseNotificationEvent: t.TypeOf<typeof SetLicenseNotificationEventDecoder>;
    // (undocumented)
    SetTaxonomyParentNotificationEvent: t.TypeOf<typeof SetTaxonomyParentNotificationEventDecoder>;
    // (undocumented)
    SetTaxonomyTermNotificationEvent: t.TypeOf<typeof SetTaxonomyTermNotificationEventDecoder>;
    // (undocumented)
    SetThreadStateNotificationEvent: t.TypeOf<typeof SetThreadStateNotificationEventDecoder>;
    // (undocumented)
    SetUuidStateNotificationEvent: t.TypeOf<typeof SetUuidStateNotificationEventDecoder>;
    // (undocumented)
    Solution: t.TypeOf<typeof SolutionDecoder>;
    // (undocumented)
    SolutionRevision: t.TypeOf<typeof SolutionRevisionDecoder>;
    // (undocumented)
    TaxonomyTerm: t.TypeOf<typeof TaxonomyTermDecoder>;
    // (undocumented)
    Thread: {
        __typename: 'Thread';
        commentPayloads: Models['Comment'][];
    };
    // (undocumented)
    User: t.TypeOf<typeof UserDecoder>;
    // (undocumented)
    Video: t.TypeOf<typeof VideoDecoder>;
    // (undocumented)
    VideoRevision: t.TypeOf<typeof VideoRevisionDecoder>;
}

// @public (undocumented)
export type Mutation = {
    __typename?: 'Mutation';
    _removeCache?: Maybe<Scalars['Boolean']>;
    _setCache?: Maybe<Scalars['Boolean']>;
    _updateCache?: Maybe<Scalars['Boolean']>;
    notification: NotificationMutation;
    subscription: SubscriptionMutation;
    thread: ThreadMutation;
    uuid: UuidMutation;
};

// @public (undocumented)
export type Mutation_RemoveCacheArgs = {
    key: Scalars['String'];
};

// @public (undocumented)
export type Mutation_SetCacheArgs = {
    key: Scalars['String'];
    value: Scalars['JSON'];
};

// @public (undocumented)
export type Mutation_UpdateCacheArgs = {
    keys: Array<Scalars['String']>;
};

// @public (undocumented)
export type MutationNamespace = MutationResolver<never, Record<string, never>>;

// @public (undocumented)
export type MutationResolver<A, T> = LegacyResolver<never, A, T extends {
    query: Query;
} ? Omit<T, 'query'> & {
    query: Record<string, never>;
} : T>;

// @public (undocumented)
export type MutationResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
    _removeCache?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<Mutation_RemoveCacheArgs, 'key'>>;
    _setCache?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<Mutation_SetCacheArgs, 'key' | 'value'>>;
    _updateCache?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<Mutation_UpdateCacheArgs, 'keys'>>;
    notification?: Resolver<ResolversTypes['NotificationMutation'], ParentType, ContextType>;
    subscription?: Resolver<ResolversTypes['SubscriptionMutation'], ParentType, ContextType>;
    thread?: Resolver<ResolversTypes['ThreadMutation'], ParentType, ContextType>;
    uuid?: Resolver<ResolversTypes['UuidMutation'], ParentType, ContextType>;
};

// @public (undocumented)
export interface MutationResponse {
    // (undocumented)
    query: Record<string, never>;
    // (undocumented)
    success: boolean;
}

// @public (undocumented)
export interface MutationResponseWithRecord<R> extends MutationResponse {
    // (undocumented)
    record: R;
}

// @public
export type Mutations<Namespaces extends keyof MutationResolvers> = {
    Mutation: Required<Pick<MutationResolvers, Namespaces>>;
} & {
    [P in `${Capitalize<Namespaces>}Mutation`]: P extends keyof Resolvers ? Required<Omit<NonNullable<Resolvers[P]>, '__isTypeOf'>> : never;
};

// @public (undocumented)
export type Navigation = {
    __typename?: 'Navigation';
    data: Scalars['JSON'];
    path: NavigationNodeConnection;
};

// @public (undocumented)
export type NavigationChildPayload = TaxonomyTermPayload | Model<'Page'>;

// @public (undocumented)
export interface NavigationData {
    // (undocumented)
    data: NodeData;
    // (undocumented)
    path: NavigationNode[];
}

// @public (undocumented)
export type NavigationNode = {
    __typename?: 'NavigationNode';
    label: Scalars['String'];
    url?: Maybe<Scalars['String']>;
    id?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type NavigationNodeConnection = {
    __typename?: 'NavigationNodeConnection';
    edges?: Maybe<Array<Maybe<NavigationNodeEdge>>>;
    nodes: Array<NavigationNode>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type NavigationNodeConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['NavigationNodeConnection'] = ResolversParentTypes['NavigationNodeConnection']> = {
    edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['NavigationNodeEdge']>>>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['NavigationNode']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type NavigationNodeEdge = {
    __typename?: 'NavigationNodeEdge';
    cursor: Scalars['String'];
    node: NavigationNode;
};

// @public (undocumented)
export type NavigationNodeEdgeResolvers<ContextType = Context, ParentType extends ResolversParentTypes['NavigationNodeEdge'] = ResolversParentTypes['NavigationNodeEdge']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['NavigationNode'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type NavigationNodeResolvers<ContextType = Context, ParentType extends ResolversParentTypes['NavigationNode'] = ResolversParentTypes['NavigationNode']> = {
    label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    id?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type NavigationPathArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export interface NavigationPayload {
    // (undocumented)
    data: NodeData[];
    // (undocumented)
    instance: Instance;
}

// @public (undocumented)
export type NavigationResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Navigation'] = ResolversParentTypes['Navigation']> = {
    data?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
    path?: Resolver<ResolversTypes['NavigationNodeConnection'], ParentType, ContextType, RequireFields<NavigationPathArgs, never>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
    selectionSet: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

// @public (undocumented)
export type NextResolverFn<T> = () => Promise<T>;

// @public (undocumented)
export interface NodeData {
    // (undocumented)
    children?: NodeData[];
    // (undocumented)
    id?: number;
    // (undocumented)
    label: string;
    // (undocumented)
    url?: string;
}

// @public (undocumented)
type Notification_2 = {
    __typename?: 'Notification';
    id: Scalars['Int'];
    unread: Scalars['Boolean'];
    event: CheckoutRevisionNotificationEvent | CreateCommentNotificationEvent | CreateEntityLinkNotificationEvent | CreateEntityNotificationEvent | CreateEntityRevisionNotificationEvent | CreateTaxonomyLinkNotificationEvent | CreateTaxonomyTermNotificationEvent | CreateThreadNotificationEvent | RejectRevisionNotificationEvent | RemoveEntityLinkNotificationEvent | RemoveTaxonomyLinkNotificationEvent | SetLicenseNotificationEvent | SetTaxonomyParentNotificationEvent | SetTaxonomyTermNotificationEvent | SetThreadStateNotificationEvent | SetUuidStateNotificationEvent;
};

export { Notification_2 as Notification }

// @public (undocumented)
export type NotificationConnection = {
    __typename?: 'NotificationConnection';
    edges: Array<NotificationEdge>;
    nodes: Array<Notification_2>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type NotificationConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['NotificationConnection'] = ResolversParentTypes['NotificationConnection']> = {
    edges?: Resolver<Array<ResolversTypes['NotificationEdge']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['Notification']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const NotificationDecoder: t.ExactC<t.TypeC<{
    id: t.NumberC;
    unread: t.BooleanC;
    eventId: t.NumberC;
}>>;

// @public (undocumented)
export type NotificationEdge = {
    __typename?: 'NotificationEdge';
    cursor: Scalars['String'];
    node: Notification_2;
};

// @public (undocumented)
export type NotificationEdgeResolvers<ContextType = Context, ParentType extends ResolversParentTypes['NotificationEdge'] = ResolversParentTypes['NotificationEdge']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['Notification'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const NotificationEventDecoder: t.UnionC<[t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CheckoutRevision>;
    repositoryId: t.RefinementC<t.NumberC>;
    revisionId: t.RefinementC<t.NumberC>;
    reason: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateComment>;
    threadId: t.RefinementC<t.NumberC>;
    commentId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateEntity>;
    entityId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateEntityRevision>;
    entityId: t.RefinementC<t.NumberC>;
    entityRevisionId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateEntityLink>;
    parentId: t.RefinementC<t.NumberC>;
    childId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateTaxonomyTerm>;
    taxonomyTermId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateTaxonomyLink>;
    parentId: t.RefinementC<t.NumberC>;
    childId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.CreateThread>;
    threadId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.RejectRevision>;
    repositoryId: t.RefinementC<t.NumberC>;
    revisionId: t.RefinementC<t.NumberC>;
    reason: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.RemoveEntityLink>;
    parentId: t.RefinementC<t.NumberC>;
    childId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.RemoveTaxonomyLink>;
    parentId: t.RefinementC<t.NumberC>;
    childId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.SetLicense>;
    repositoryId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.SetTaxonomyTerm>;
    taxonomyTermId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.SetTaxonomyParent>;
    previousParentId: t.RefinementC<t.NumberC>;
    parentId: t.RefinementC<t.NumberC>;
    childId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.SetThreadState>;
    threadId: t.RefinementC<t.NumberC>;
    archived: t.BooleanC;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.SetUuidState>;
    trashed: t.BooleanC;
}>]>>]>;

// @public (undocumented)
export enum NotificationEventType {
    // (undocumented)
    CheckoutRevision = "CheckoutRevisionNotificationEvent",
    // (undocumented)
    CreateComment = "CreateCommentNotificationEvent",
    // (undocumented)
    CreateEntity = "CreateEntityNotificationEvent",
    // (undocumented)
    CreateEntityLink = "CreateEntityLinkNotificationEvent",
    // (undocumented)
    CreateEntityRevision = "CreateEntityRevisionNotificationEvent",
    // (undocumented)
    CreateTaxonomyLink = "CreateTaxonomyLinkNotificationEvent",
    // (undocumented)
    CreateTaxonomyTerm = "CreateTaxonomyTermNotificationEvent",
    // (undocumented)
    CreateThread = "CreateThreadNotificationEvent",
    // (undocumented)
    RejectRevision = "RejectRevisionNotificationEvent",
    // (undocumented)
    RemoveEntityLink = "RemoveEntityLinkNotificationEvent",
    // (undocumented)
    RemoveTaxonomyLink = "RemoveTaxonomyLinkNotificationEvent",
    // (undocumented)
    SetLicense = "SetLicenseNotificationEvent",
    // (undocumented)
    SetTaxonomyParent = "SetTaxonomyParentNotificationEvent",
    // (undocumented)
    SetTaxonomyTerm = "SetTaxonomyTermNotificationEvent",
    // (undocumented)
    SetThreadState = "SetThreadStateNotificationEvent",
    // (undocumented)
    SetUuidState = "SetUuidStateNotificationEvent"
}

// @public (undocumented)
export type NotificationMutation = {
    __typename?: 'NotificationMutation';
    setState?: Maybe<NotificationSetStateResponse>;
};

// @public (undocumented)
export type NotificationMutationResolvers<ContextType = Context, ParentType extends ResolversParentTypes['NotificationMutation'] = ResolversParentTypes['NotificationMutation']> = {
    setState?: Resolver<Maybe<ResolversTypes['NotificationSetStateResponse']>, ParentType, ContextType, RequireFields<NotificationMutationSetStateArgs, 'input'>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type NotificationMutationSetStateArgs = {
    input: NotificationSetStateInput;
};

// @public (undocumented)
export type NotificationResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Notification'] = ResolversParentTypes['Notification']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    unread?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    event?: Resolver<ResolversTypes['AbstractNotificationEvent'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type NotificationSetStateInput = {
    id: Array<Scalars['Int']>;
    unread: Scalars['Boolean'];
};

// @public (undocumented)
export type NotificationSetStateResponse = {
    __typename?: 'NotificationSetStateResponse';
    success: Scalars['Boolean'];
    query: Query;
};

// @public (undocumented)
export type NotificationSetStateResponseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['NotificationSetStateResponse'] = ResolversParentTypes['NotificationSetStateResponse']> = {
    success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public
export type OmitKeys<O extends object, Keys> = Omit<O, Keys & keyof O>;

// @public (undocumented)
export type Page = AbstractUuid & AbstractRepository & AbstractNavigationChild & InstanceAware & ThreadAware & {
    __typename?: 'Page';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    license: License;
    currentRevision?: Maybe<PageRevision>;
    revisions: PageRevisionConnection;
    navigation?: Maybe<Navigation>;
};

// @public (undocumented)
export const PageDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<DiscriminatorType.Page>;
    instance: t.Type<Instance, Instance, unknown>;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    date: t.StringC;
    licenseId: t.NumberC;
}>]>>;

// @public (undocumented)
export type PageInfo = {
    __typename?: 'PageInfo';
    hasNextPage: Scalars['Boolean'];
    hasPreviousPage: Scalars['Boolean'];
    startCursor?: Maybe<Scalars['String']>;
    endCursor?: Maybe<Scalars['String']>;
};

// @public (undocumented)
export type PageInfoResolvers<ContextType = Context, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
    hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type PageResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Page'] = ResolversParentTypes['Page']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<PageThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['PageRevision']>, ParentType, ContextType>;
    revisions?: Resolver<ResolversTypes['PageRevisionConnection'], ParentType, ContextType, RequireFields<PageRevisionsArgs, never>>;
    navigation?: Resolver<Maybe<ResolversTypes['Navigation']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type PageRevision = AbstractUuid & AbstractRevision & ThreadAware & {
    __typename?: 'PageRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    title: Scalars['String'];
    content: Scalars['String'];
    repository: Page;
};

// @public (undocumented)
export type PageRevisionConnection = {
    __typename?: 'PageRevisionConnection';
    edges: Array<PageRevisionCursor>;
    nodes: Array<PageRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type PageRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['PageRevisionConnection'] = ResolversParentTypes['PageRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['PageRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['PageRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type PageRevisionCursor = {
    __typename?: 'PageRevisionCursor';
    cursor: Scalars['String'];
    node: PageRevision;
};

// @public (undocumented)
export type PageRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['PageRevisionCursor'] = ResolversParentTypes['PageRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['PageRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const PageRevisionDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<DiscriminatorType.PageRevision>;
    title: t.StringC;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type PageRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['PageRevision'] = ResolversParentTypes['PageRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<PageRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['Page'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type PageRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type PageRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type PageThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type Payload<M extends keyof AllPayloads, P extends keyof AllPayloads[M]> = AllPayloads[M][P];

// @public (undocumented)
export type PayloadArrayOrPayload<P> = {
    payload: P;
} | {
    payloads: P[];
};

// @public (undocumented)
export type Payloads<M> = {
    [F in keyof M]: NonNullable<A.PromiseOf<M[F] extends (...args: any) => infer R ? R : never>>;
};

// @public
export type PickKeys<O extends object, Keys> = Pick<O, Keys & keyof O>;

// @public (undocumented)
export type PickRequiredResolvers<O extends object> = O.Filter<O, object, '<-extends'>;

// @public
export type PickResolvers<R extends keyof Resolvers, F = O.OptionalKeys<GetResolver<R>>> = Required<PickKeys<GetResolver<R>, F>>;

// @public (undocumented)
export enum Priority {
    // (undocumented)
    High = 1,
    // (undocumented)
    Low = 0
}

// @public
export type Queries<QueryProperties extends keyof QueryResolvers> = A.Compute<{
    Query: Required<Pick<QueryResolvers, QueryProperties>>;
}, 'deep'>;

// @public (undocumented)
export type Query = {
    __typename?: 'Query';
    activeAuthors: UserConnection;
    activeDonors: UserConnection;
    activeReviewers: UserConnection;
    authorization: Scalars['JSON'];
    license?: Maybe<License>;
    notificationEvent?: Maybe<CheckoutRevisionNotificationEvent | CreateCommentNotificationEvent | CreateEntityLinkNotificationEvent | CreateEntityNotificationEvent | CreateEntityRevisionNotificationEvent | CreateTaxonomyLinkNotificationEvent | CreateTaxonomyTermNotificationEvent | CreateThreadNotificationEvent | RejectRevisionNotificationEvent | RemoveEntityLinkNotificationEvent | RemoveTaxonomyLinkNotificationEvent | SetLicenseNotificationEvent | SetTaxonomyParentNotificationEvent | SetTaxonomyTermNotificationEvent | SetThreadStateNotificationEvent | SetUuidStateNotificationEvent>;
    notifications: NotificationConnection;
    subscriptions: QuerySubscriptionResult;
    uuid?: Maybe<Comment | Applet | AppletRevision | Article | ArticleRevision | CoursePage | CoursePageRevision | Course | CourseRevision | Event_2 | EventRevision | ExerciseGroup | ExerciseGroupRevision | Exercise | ExerciseRevision | GroupedExercise | GroupedExerciseRevision | Page | PageRevision | Solution | SolutionRevision | TaxonomyTerm | User | Video | VideoRevision>;
};

// @public (undocumented)
export type QueryActiveAuthorsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type QueryActiveDonorsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type QueryActiveReviewersArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type QueryLicenseArgs = {
    id: Scalars['Int'];
};

// @public (undocumented)
export type QueryNotificationEventArgs = {
    id: Scalars['Int'];
};

// @public (undocumented)
export type QueryNotificationsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unread?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type QueryResolver<A, T> = LegacyResolver<never, A, T>;

// @public (undocumented)
export type QueryResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
    activeAuthors?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<QueryActiveAuthorsArgs, never>>;
    activeDonors?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<QueryActiveDonorsArgs, never>>;
    activeReviewers?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<QueryActiveReviewersArgs, never>>;
    authorization?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
    license?: Resolver<Maybe<ResolversTypes['License']>, ParentType, ContextType, RequireFields<QueryLicenseArgs, 'id'>>;
    notificationEvent?: Resolver<Maybe<ResolversTypes['AbstractNotificationEvent']>, ParentType, ContextType, RequireFields<QueryNotificationEventArgs, 'id'>>;
    notifications?: Resolver<ResolversTypes['NotificationConnection'], ParentType, ContextType, RequireFields<QueryNotificationsArgs, never>>;
    subscriptions?: Resolver<ResolversTypes['QuerySubscriptionResult'], ParentType, ContextType, RequireFields<QuerySubscriptionsArgs, never>>;
    uuid?: Resolver<Maybe<ResolversTypes['AbstractUuid']>, ParentType, ContextType, RequireFields<QueryUuidArgs, never>>;
};

// @public (undocumented)
export interface QuerySpec<P, R> {
    // (undocumented)
    decoder?: t.Type<R>;
    // (undocumented)
    enableSwr: boolean;
    // (undocumented)
    getCurrentValue: (payload: P, previousValue: R | null) => Promise<R | unknown>;
    // (undocumented)
    getKey: (payload: P) => string;
    // (undocumented)
    getPayload: (key: string) => option.Option<P>;
    // (undocumented)
    maxAge: Time | undefined;
    // (undocumented)
    swrFrequency?: number;
}

// @public (undocumented)
export interface QuerySpecWithHelpers<P, R> extends QuerySpec<P, R> {
    // (undocumented)
    queryWithDecoder<S extends R>(payload: P, customDecoder: t.Type<S>): Promise<S>;
    // (undocumented)
    queryWithDecoders<S2 extends R, S1 extends S2>(payload: P, customDecoder1: t.Type<S1>, customDecoder2: t.Type<S2>): Promise<S2>;
    // (undocumented)
    setCache: (args: PayloadArrayOrPayload<P> & FunctionOrValue<R>) => Promise<void>;
}

// @public (undocumented)
export type QuerySubscriptionResult = {
    __typename?: 'QuerySubscriptionResult';
    edges: Array<SubscriptionCursor>;
    nodes: Array<Comment | Applet | AppletRevision | Article | ArticleRevision | CoursePage | CoursePageRevision | Course | CourseRevision | Event_2 | EventRevision | ExerciseGroup | ExerciseGroupRevision | Exercise | ExerciseRevision | GroupedExercise | GroupedExerciseRevision | Page | PageRevision | Solution | SolutionRevision | TaxonomyTerm | User | Video | VideoRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type QuerySubscriptionResultResolvers<ContextType = Context, ParentType extends ResolversParentTypes['QuerySubscriptionResult'] = ResolversParentTypes['QuerySubscriptionResult']> = {
    edges?: Resolver<Array<ResolversTypes['SubscriptionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['AbstractUuid']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type QuerySubscriptionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type QueryUuidArgs = {
    alias?: Maybe<AliasInput>;
    id?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export const queueName = "swr";

// @public (undocumented)
export type RejectRevisionNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'RejectRevisionNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    repository: Applet | Article | CoursePage | Course | Event_2 | ExerciseGroup | Exercise | GroupedExercise | Page | Solution | Video;
    revision: AppletRevision | ArticleRevision | CoursePageRevision | CourseRevision | EventRevision | ExerciseGroupRevision | ExerciseRevision | GroupedExerciseRevision | PageRevision | SolutionRevision | VideoRevision;
    reason: Scalars['String'];
};

// @public (undocumented)
export const RejectRevisionNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.RejectRevision>;
    repositoryId: t.RefinementC<t.NumberC>;
    revisionId: t.RefinementC<t.NumberC>;
    reason: t.StringC;
}>]>>;

// @public (undocumented)
export type RejectRevisionNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['RejectRevisionNotificationEvent'] = ResolversParentTypes['RejectRevisionNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['AbstractRepository'], ParentType, ContextType>;
    revision?: Resolver<ResolversTypes['AbstractRevision'], ParentType, ContextType>;
    reason?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type RemoveEntityLinkNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'RemoveEntityLinkNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    parent: Applet | Article | CoursePage | Course | Event_2 | ExerciseGroup | Exercise | GroupedExercise | Solution | Video;
    child: Applet | Article | CoursePage | Course | Event_2 | ExerciseGroup | Exercise | GroupedExercise | Solution | Video;
};

// @public (undocumented)
export const RemoveEntityLinkNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.RemoveEntityLink>;
    parentId: t.RefinementC<t.NumberC>;
    childId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type RemoveEntityLinkNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['RemoveEntityLinkNotificationEvent'] = ResolversParentTypes['RemoveEntityLinkNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    parent?: Resolver<ResolversTypes['AbstractEntity'], ParentType, ContextType>;
    child?: Resolver<ResolversTypes['AbstractEntity'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type RemoveTaxonomyLinkNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'RemoveTaxonomyLinkNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    parent: TaxonomyTerm;
    child: Comment | Applet | AppletRevision | Article | ArticleRevision | CoursePage | CoursePageRevision | Course | CourseRevision | Event_2 | EventRevision | ExerciseGroup | ExerciseGroupRevision | Exercise | ExerciseRevision | GroupedExercise | GroupedExerciseRevision | Page | PageRevision | Solution | SolutionRevision | TaxonomyTerm | User | Video | VideoRevision;
};

// @public (undocumented)
export const RemoveTaxonomyLinkNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.RemoveTaxonomyLink>;
    parentId: t.RefinementC<t.NumberC>;
    childId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type RemoveTaxonomyLinkNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['RemoveTaxonomyLinkNotificationEvent'] = ResolversParentTypes['RemoveTaxonomyLinkNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    parent?: Resolver<ResolversTypes['TaxonomyTerm'], ParentType, ContextType>;
    child?: Resolver<ResolversTypes['AbstractUuid'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type Repository<R extends Model<'AbstractRevision'>['__typename']> = Model<R extends `${infer U}Revision` ? U : never>;

// @public (undocumented)
export const RepositoryDecoder: t.UnionC<[t.UnionC<[t.UnionC<[t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Exercise>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    solutionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.GroupedExercise>;
    parentId: t.RefinementC<t.NumberC>;
    solutionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>]>>]>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Applet>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Article>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Course>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    pageIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.CoursePage>;
    parentId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Event>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.ExerciseGroup>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    exerciseIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Solution>;
    parentId: t.NumberC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Video>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>]>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<DiscriminatorType.Page>;
    instance: t.Type<Instance, Instance, unknown>;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    date: t.StringC;
    licenseId: t.NumberC;
}>]>>]>;

// @public (undocumented)
export type RepositoryPayload = Model<'AbstractRepository'>;

// @public (undocumented)
export type RepositoryType = EntityType | DiscriminatorType.Page;

// @public (undocumented)
export type RequiredResolverFunctions<T extends object> = Typename<T> extends keyof Resolvers ? OmitKeys<Required<GetResolver<Typename<T>>>, Model<Typename<T>> extends object ? O.IntersectKeys<T, Model<Typename<T>>, '<-extends'> | '__isTypeOf' : never> : never;

// @public (undocumented)
export type RequiredResolvers<T extends object> = PickRequiredResolvers<{
    [P in Typename<T>]: RequiredResolverFunctions<T>;
}>;

// @public (undocumented)
export type RequireFields<T, K extends keyof T> = {
    [X in Exclude<keyof T, K>]?: T[X];
} & {
    [P in K]-?: NonNullable<T[P]>;
};

// @public (undocumented)
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | StitchingResolver<TResult, TParent, TContext, TArgs>;

// @public (undocumented)
export type ResolverFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => Promise<TResult> | TResult;

// @public (undocumented)
export type ResolverFunction<Result, Parent, Args = {}> = Resolver<Result, Parent, Context, Args>;

// @public (undocumented)
export type Resolvers<ContextType = Context> = {
    Query?: QueryResolvers<ContextType>;
    Mutation?: MutationResolvers<ContextType>;
    PageInfo?: PageInfoResolvers<ContextType>;
    DateTime?: GraphQLScalarType;
    InstanceAware?: InstanceAwareResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    JSONObject?: GraphQLScalarType;
    License?: LicenseResolvers<ContextType>;
    CheckoutRevisionNotificationEvent?: CheckoutRevisionNotificationEventResolvers<ContextType>;
    CreateCommentNotificationEvent?: CreateCommentNotificationEventResolvers<ContextType>;
    CreateEntityLinkNotificationEvent?: CreateEntityLinkNotificationEventResolvers<ContextType>;
    CreateEntityNotificationEvent?: CreateEntityNotificationEventResolvers<ContextType>;
    CreateEntityRevisionNotificationEvent?: CreateEntityRevisionNotificationEventResolvers<ContextType>;
    CreateTaxonomyLinkNotificationEvent?: CreateTaxonomyLinkNotificationEventResolvers<ContextType>;
    CreateTaxonomyTermNotificationEvent?: CreateTaxonomyTermNotificationEventResolvers<ContextType>;
    CreateThreadNotificationEvent?: CreateThreadNotificationEventResolvers<ContextType>;
    RejectRevisionNotificationEvent?: RejectRevisionNotificationEventResolvers<ContextType>;
    RemoveEntityLinkNotificationEvent?: RemoveEntityLinkNotificationEventResolvers<ContextType>;
    RemoveTaxonomyLinkNotificationEvent?: RemoveTaxonomyLinkNotificationEventResolvers<ContextType>;
    SetLicenseNotificationEvent?: SetLicenseNotificationEventResolvers<ContextType>;
    SetTaxonomyParentNotificationEvent?: SetTaxonomyParentNotificationEventResolvers<ContextType>;
    SetTaxonomyTermNotificationEvent?: SetTaxonomyTermNotificationEventResolvers<ContextType>;
    SetThreadStateNotificationEvent?: SetThreadStateNotificationEventResolvers<ContextType>;
    SetUuidStateNotificationEvent?: SetUuidStateNotificationEventResolvers<ContextType>;
    Notification?: NotificationResolvers<ContextType>;
    AbstractNotificationEvent?: AbstractNotificationEventResolvers<ContextType>;
    NotificationMutation?: NotificationMutationResolvers<ContextType>;
    NotificationSetStateResponse?: NotificationSetStateResponseResolvers<ContextType>;
    NotificationConnection?: NotificationConnectionResolvers<ContextType>;
    NotificationEdge?: NotificationEdgeResolvers<ContextType>;
    ScopedRole?: ScopedRoleResolvers<ContextType>;
    ScopedRoleConnection?: ScopedRoleConnectionResolvers<ContextType>;
    ScopedRoleCursor?: ScopedRoleCursorResolvers<ContextType>;
    QuerySubscriptionResult?: QuerySubscriptionResultResolvers<ContextType>;
    SubscriptionCursor?: SubscriptionCursorResolvers<ContextType>;
    SubscriptionMutation?: SubscriptionMutationResolvers<ContextType>;
    SubscriptionSetResponse?: SubscriptionSetResponseResolvers<ContextType>;
    Thread?: ThreadResolvers<ContextType>;
    Comment?: CommentResolvers<ContextType>;
    ThreadAware?: ThreadAwareResolvers<ContextType>;
    ThreadsConnection?: ThreadsConnectionResolvers<ContextType>;
    ThreadsCursor?: ThreadsCursorResolvers<ContextType>;
    UnsupportedThread?: UnsupportedThreadResolvers<ContextType>;
    UnsupportedComment?: UnsupportedCommentResolvers<ContextType>;
    CommentConnection?: CommentConnectionResolvers<ContextType>;
    CommentEdge?: CommentEdgeResolvers<ContextType>;
    ThreadMutation?: ThreadMutationResolvers<ContextType>;
    ThreadCreateThreadResponse?: ThreadCreateThreadResponseResolvers<ContextType>;
    ThreadCreateCommentResponse?: ThreadCreateCommentResponseResolvers<ContextType>;
    ThreadSetThreadArchivedResponse?: ThreadSetThreadArchivedResponseResolvers<ContextType>;
    ThreadSetThreadStateResponse?: ThreadSetThreadStateResponseResolvers<ContextType>;
    ThreadSetCommentStateResponse?: ThreadSetCommentStateResponseResolvers<ContextType>;
    AbstractEntity?: AbstractEntityResolvers<ContextType>;
    AbstractEntityRevision?: AbstractEntityRevisionResolvers<ContextType>;
    AbstractExercise?: AbstractExerciseResolvers<ContextType>;
    AbstractExerciseRevision?: AbstractExerciseRevisionResolvers<ContextType>;
    AbstractNavigationChild?: AbstractNavigationChildResolvers<ContextType>;
    Navigation?: NavigationResolvers<ContextType>;
    NavigationNodeConnection?: NavigationNodeConnectionResolvers<ContextType>;
    NavigationNodeEdge?: NavigationNodeEdgeResolvers<ContextType>;
    NavigationNode?: NavigationNodeResolvers<ContextType>;
    AbstractRepository?: AbstractRepositoryResolvers<ContextType>;
    AbstractRevision?: AbstractRevisionResolvers<ContextType>;
    AbstractTaxonomyTermChild?: AbstractTaxonomyTermChildResolvers<ContextType>;
    TaxonomyTermConnection?: TaxonomyTermConnectionResolvers<ContextType>;
    TaxonomyTermEdge?: TaxonomyTermEdgeResolvers<ContextType>;
    AbstractUuid?: AbstractUuidResolvers<ContextType>;
    AbstractUuidConnection?: AbstractUuidConnectionResolvers<ContextType>;
    AbstractUuidCursor?: AbstractUuidCursorResolvers<ContextType>;
    UuidMutation?: UuidMutationResolvers<ContextType>;
    UuidSetStateResponse?: UuidSetStateResponseResolvers<ContextType>;
    Applet?: AppletResolvers<ContextType>;
    AppletRevision?: AppletRevisionResolvers<ContextType>;
    AppletRevisionConnection?: AppletRevisionConnectionResolvers<ContextType>;
    AppletRevisionCursor?: AppletRevisionCursorResolvers<ContextType>;
    Article?: ArticleResolvers<ContextType>;
    ArticleRevision?: ArticleRevisionResolvers<ContextType>;
    ArticleRevisionConnection?: ArticleRevisionConnectionResolvers<ContextType>;
    ArticleRevisionCursor?: ArticleRevisionCursorResolvers<ContextType>;
    CoursePage?: CoursePageResolvers<ContextType>;
    CoursePageRevision?: CoursePageRevisionResolvers<ContextType>;
    CoursePageRevisionConnection?: CoursePageRevisionConnectionResolvers<ContextType>;
    CoursePageRevisionCursor?: CoursePageRevisionCursorResolvers<ContextType>;
    Course?: CourseResolvers<ContextType>;
    CourseRevision?: CourseRevisionResolvers<ContextType>;
    CourseRevisionConnection?: CourseRevisionConnectionResolvers<ContextType>;
    CourseRevisionCursor?: CourseRevisionCursorResolvers<ContextType>;
    Event?: EventResolvers<ContextType>;
    EventRevision?: EventRevisionResolvers<ContextType>;
    EventRevisionConnection?: EventRevisionConnectionResolvers<ContextType>;
    EventRevisionCursor?: EventRevisionCursorResolvers<ContextType>;
    ExerciseGroup?: ExerciseGroupResolvers<ContextType>;
    ExerciseGroupRevision?: ExerciseGroupRevisionResolvers<ContextType>;
    ExerciseGroupRevisionConnection?: ExerciseGroupRevisionConnectionResolvers<ContextType>;
    ExerciseGroupRevisionCursor?: ExerciseGroupRevisionCursorResolvers<ContextType>;
    Exercise?: ExerciseResolvers<ContextType>;
    ExerciseRevision?: ExerciseRevisionResolvers<ContextType>;
    ExerciseRevisionConnection?: ExerciseRevisionConnectionResolvers<ContextType>;
    ExerciseRevisionCursor?: ExerciseRevisionCursorResolvers<ContextType>;
    GroupedExercise?: GroupedExerciseResolvers<ContextType>;
    GroupedExerciseRevision?: GroupedExerciseRevisionResolvers<ContextType>;
    GroupedExerciseRevisionConnection?: GroupedExerciseRevisionConnectionResolvers<ContextType>;
    GroupedExerciseRevisionCursor?: GroupedExerciseRevisionCursorResolvers<ContextType>;
    Page?: PageResolvers<ContextType>;
    PageRevision?: PageRevisionResolvers<ContextType>;
    PageRevisionConnection?: PageRevisionConnectionResolvers<ContextType>;
    PageRevisionCursor?: PageRevisionCursorResolvers<ContextType>;
    Solution?: SolutionResolvers<ContextType>;
    SolutionRevision?: SolutionRevisionResolvers<ContextType>;
    SolutionRevisionConnection?: SolutionRevisionConnectionResolvers<ContextType>;
    SolutionRevisionCursor?: SolutionRevisionCursorResolvers<ContextType>;
    TaxonomyTerm?: TaxonomyTermResolvers<ContextType>;
    User?: UserResolvers<ContextType>;
    UserConnection?: UserConnectionResolvers<ContextType>;
    UserEdge?: UserEdgeResolvers<ContextType>;
    Video?: VideoResolvers<ContextType>;
    VideoRevision?: VideoRevisionResolvers<ContextType>;
    VideoRevisionConnection?: VideoRevisionConnectionResolvers<ContextType>;
    VideoRevisionCursor?: VideoRevisionCursorResolvers<ContextType>;
};

// @public
export type ResolversParentTypes = {
    Query: {};
    String: ModelOf<Scalars['String']>;
    Int: ModelOf<Scalars['Int']>;
    Boolean: ModelOf<Scalars['Boolean']>;
    Mutation: {};
    PageInfo: ModelOf<PageInfo>;
    DateTime: ModelOf<Scalars['DateTime']>;
    InstanceAware: ResolversParentTypes['CheckoutRevisionNotificationEvent'] | ResolversParentTypes['CreateCommentNotificationEvent'] | ResolversParentTypes['CreateEntityLinkNotificationEvent'] | ResolversParentTypes['CreateEntityNotificationEvent'] | ResolversParentTypes['CreateEntityRevisionNotificationEvent'] | ResolversParentTypes['CreateTaxonomyLinkNotificationEvent'] | ResolversParentTypes['CreateTaxonomyTermNotificationEvent'] | ResolversParentTypes['CreateThreadNotificationEvent'] | ResolversParentTypes['RejectRevisionNotificationEvent'] | ResolversParentTypes['RemoveEntityLinkNotificationEvent'] | ResolversParentTypes['RemoveTaxonomyLinkNotificationEvent'] | ResolversParentTypes['SetLicenseNotificationEvent'] | ResolversParentTypes['SetTaxonomyParentNotificationEvent'] | ResolversParentTypes['SetTaxonomyTermNotificationEvent'] | ResolversParentTypes['SetThreadStateNotificationEvent'] | ResolversParentTypes['SetUuidStateNotificationEvent'] | ResolversParentTypes['Applet'] | ResolversParentTypes['Article'] | ResolversParentTypes['CoursePage'] | ResolversParentTypes['Course'] | ResolversParentTypes['Event'] | ResolversParentTypes['ExerciseGroup'] | ResolversParentTypes['Exercise'] | ResolversParentTypes['GroupedExercise'] | ResolversParentTypes['Page'] | ResolversParentTypes['Solution'] | ResolversParentTypes['TaxonomyTerm'] | ResolversParentTypes['Video'];
    JSON: ModelOf<Scalars['JSON']>;
    JSONObject: ModelOf<Scalars['JSONObject']>;
    License: ModelOf<License>;
    CheckoutRevisionNotificationEvent: ModelOf<CheckoutRevisionNotificationEvent>;
    CreateCommentNotificationEvent: ModelOf<CreateCommentNotificationEvent>;
    CreateEntityLinkNotificationEvent: ModelOf<CreateEntityLinkNotificationEvent>;
    CreateEntityNotificationEvent: ModelOf<CreateEntityNotificationEvent>;
    CreateEntityRevisionNotificationEvent: ModelOf<CreateEntityRevisionNotificationEvent>;
    CreateTaxonomyLinkNotificationEvent: ModelOf<CreateTaxonomyLinkNotificationEvent>;
    CreateTaxonomyTermNotificationEvent: ModelOf<CreateTaxonomyTermNotificationEvent>;
    CreateThreadNotificationEvent: ModelOf<CreateThreadNotificationEvent>;
    RejectRevisionNotificationEvent: ModelOf<RejectRevisionNotificationEvent>;
    RemoveEntityLinkNotificationEvent: ModelOf<RemoveEntityLinkNotificationEvent>;
    RemoveTaxonomyLinkNotificationEvent: ModelOf<RemoveTaxonomyLinkNotificationEvent>;
    SetLicenseNotificationEvent: ModelOf<SetLicenseNotificationEvent>;
    SetTaxonomyParentNotificationEvent: ModelOf<SetTaxonomyParentNotificationEvent>;
    SetTaxonomyTermNotificationEvent: ModelOf<SetTaxonomyTermNotificationEvent>;
    SetThreadStateNotificationEvent: ModelOf<SetThreadStateNotificationEvent>;
    SetUuidStateNotificationEvent: ModelOf<SetUuidStateNotificationEvent>;
    Notification: ModelOf<Notification_2>;
    AbstractNotificationEvent: ResolversParentTypes['CheckoutRevisionNotificationEvent'] | ResolversParentTypes['CreateCommentNotificationEvent'] | ResolversParentTypes['CreateEntityLinkNotificationEvent'] | ResolversParentTypes['CreateEntityNotificationEvent'] | ResolversParentTypes['CreateEntityRevisionNotificationEvent'] | ResolversParentTypes['CreateTaxonomyLinkNotificationEvent'] | ResolversParentTypes['CreateTaxonomyTermNotificationEvent'] | ResolversParentTypes['CreateThreadNotificationEvent'] | ResolversParentTypes['RejectRevisionNotificationEvent'] | ResolversParentTypes['RemoveEntityLinkNotificationEvent'] | ResolversParentTypes['RemoveTaxonomyLinkNotificationEvent'] | ResolversParentTypes['SetLicenseNotificationEvent'] | ResolversParentTypes['SetTaxonomyParentNotificationEvent'] | ResolversParentTypes['SetTaxonomyTermNotificationEvent'] | ResolversParentTypes['SetThreadStateNotificationEvent'] | ResolversParentTypes['SetUuidStateNotificationEvent'];
    NotificationMutation: ModelOf<NotificationMutation>;
    NotificationSetStateInput: ModelOf<NotificationSetStateInput>;
    NotificationSetStateResponse: ModelOf<NotificationSetStateResponse>;
    NotificationConnection: ModelOf<NotificationConnection>;
    NotificationEdge: ModelOf<NotificationEdge>;
    ScopedRole: ModelOf<ScopedRole>;
    ScopedRoleConnection: ModelOf<ScopedRoleConnection>;
    ScopedRoleCursor: ModelOf<ScopedRoleCursor>;
    QuerySubscriptionResult: ModelOf<QuerySubscriptionResult>;
    SubscriptionCursor: ModelOf<SubscriptionCursor>;
    SubscriptionMutation: ModelOf<SubscriptionMutation>;
    SubscriptionSetInput: ModelOf<SubscriptionSetInput>;
    SubscriptionSetResponse: ModelOf<SubscriptionSetResponse>;
    Thread: ModelOf<Thread>;
    Comment: ModelOf<Comment>;
    ThreadAware: ResolversParentTypes['Applet'] | ResolversParentTypes['AppletRevision'] | ResolversParentTypes['Article'] | ResolversParentTypes['ArticleRevision'] | ResolversParentTypes['CoursePage'] | ResolversParentTypes['CoursePageRevision'] | ResolversParentTypes['Course'] | ResolversParentTypes['CourseRevision'] | ResolversParentTypes['Event'] | ResolversParentTypes['EventRevision'] | ResolversParentTypes['ExerciseGroup'] | ResolversParentTypes['ExerciseGroupRevision'] | ResolversParentTypes['Exercise'] | ResolversParentTypes['ExerciseRevision'] | ResolversParentTypes['GroupedExercise'] | ResolversParentTypes['GroupedExerciseRevision'] | ResolversParentTypes['Page'] | ResolversParentTypes['PageRevision'] | ResolversParentTypes['Solution'] | ResolversParentTypes['SolutionRevision'] | ResolversParentTypes['TaxonomyTerm'] | ResolversParentTypes['User'] | ResolversParentTypes['Video'] | ResolversParentTypes['VideoRevision'];
    ThreadsConnection: ModelOf<ThreadsConnection>;
    ThreadsCursor: ModelOf<ThreadsCursor>;
    UnsupportedThread: ModelOf<UnsupportedThread>;
    UnsupportedComment: ModelOf<UnsupportedComment>;
    CommentConnection: ModelOf<CommentConnection>;
    CommentEdge: ModelOf<CommentEdge>;
    ThreadMutation: ModelOf<ThreadMutation>;
    ThreadCreateThreadInput: ModelOf<ThreadCreateThreadInput>;
    ThreadCreateThreadResponse: ModelOf<ThreadCreateThreadResponse>;
    ThreadCreateCommentInput: ModelOf<ThreadCreateCommentInput>;
    ThreadCreateCommentResponse: ModelOf<ThreadCreateCommentResponse>;
    ThreadSetThreadArchivedInput: ModelOf<ThreadSetThreadArchivedInput>;
    ThreadSetThreadArchivedResponse: ModelOf<ThreadSetThreadArchivedResponse>;
    ThreadSetThreadStateInput: ModelOf<ThreadSetThreadStateInput>;
    ThreadSetThreadStateResponse: ModelOf<ThreadSetThreadStateResponse>;
    ThreadSetCommentStateInput: ModelOf<ThreadSetCommentStateInput>;
    ThreadSetCommentStateResponse: ModelOf<ThreadSetCommentStateResponse>;
    AbstractEntity: ResolversParentTypes['Applet'] | ResolversParentTypes['Article'] | ResolversParentTypes['CoursePage'] | ResolversParentTypes['Course'] | ResolversParentTypes['Event'] | ResolversParentTypes['ExerciseGroup'] | ResolversParentTypes['Exercise'] | ResolversParentTypes['GroupedExercise'] | ResolversParentTypes['Solution'] | ResolversParentTypes['Video'];
    AbstractEntityRevision: ResolversParentTypes['AppletRevision'] | ResolversParentTypes['ArticleRevision'] | ResolversParentTypes['CoursePageRevision'] | ResolversParentTypes['CourseRevision'] | ResolversParentTypes['EventRevision'] | ResolversParentTypes['ExerciseGroupRevision'] | ResolversParentTypes['ExerciseRevision'] | ResolversParentTypes['GroupedExerciseRevision'] | ResolversParentTypes['SolutionRevision'] | ResolversParentTypes['VideoRevision'];
    AbstractExercise: ResolversParentTypes['Exercise'] | ResolversParentTypes['GroupedExercise'];
    AbstractExerciseRevision: ResolversParentTypes['ExerciseRevision'] | ResolversParentTypes['GroupedExerciseRevision'];
    AbstractNavigationChild: ResolversParentTypes['Page'] | ResolversParentTypes['TaxonomyTerm'];
    Navigation: ModelOf<Navigation>;
    NavigationNodeConnection: ModelOf<NavigationNodeConnection>;
    NavigationNodeEdge: ModelOf<NavigationNodeEdge>;
    NavigationNode: ModelOf<NavigationNode>;
    AbstractRepository: ResolversParentTypes['Applet'] | ResolversParentTypes['Article'] | ResolversParentTypes['CoursePage'] | ResolversParentTypes['Course'] | ResolversParentTypes['Event'] | ResolversParentTypes['ExerciseGroup'] | ResolversParentTypes['Exercise'] | ResolversParentTypes['GroupedExercise'] | ResolversParentTypes['Page'] | ResolversParentTypes['Solution'] | ResolversParentTypes['Video'];
    AbstractRevision: ResolversParentTypes['AppletRevision'] | ResolversParentTypes['ArticleRevision'] | ResolversParentTypes['CoursePageRevision'] | ResolversParentTypes['CourseRevision'] | ResolversParentTypes['EventRevision'] | ResolversParentTypes['ExerciseGroupRevision'] | ResolversParentTypes['ExerciseRevision'] | ResolversParentTypes['GroupedExerciseRevision'] | ResolversParentTypes['PageRevision'] | ResolversParentTypes['SolutionRevision'] | ResolversParentTypes['VideoRevision'];
    AbstractTaxonomyTermChild: ResolversParentTypes['Applet'] | ResolversParentTypes['Article'] | ResolversParentTypes['Course'] | ResolversParentTypes['Event'] | ResolversParentTypes['ExerciseGroup'] | ResolversParentTypes['Exercise'] | ResolversParentTypes['Video'];
    TaxonomyTermConnection: ModelOf<TaxonomyTermConnection>;
    TaxonomyTermEdge: ModelOf<TaxonomyTermEdge>;
    AbstractUuid: ResolversParentTypes['Comment'] | ResolversParentTypes['Applet'] | ResolversParentTypes['AppletRevision'] | ResolversParentTypes['Article'] | ResolversParentTypes['ArticleRevision'] | ResolversParentTypes['CoursePage'] | ResolversParentTypes['CoursePageRevision'] | ResolversParentTypes['Course'] | ResolversParentTypes['CourseRevision'] | ResolversParentTypes['Event'] | ResolversParentTypes['EventRevision'] | ResolversParentTypes['ExerciseGroup'] | ResolversParentTypes['ExerciseGroupRevision'] | ResolversParentTypes['Exercise'] | ResolversParentTypes['ExerciseRevision'] | ResolversParentTypes['GroupedExercise'] | ResolversParentTypes['GroupedExerciseRevision'] | ResolversParentTypes['Page'] | ResolversParentTypes['PageRevision'] | ResolversParentTypes['Solution'] | ResolversParentTypes['SolutionRevision'] | ResolversParentTypes['TaxonomyTerm'] | ResolversParentTypes['User'] | ResolversParentTypes['Video'] | ResolversParentTypes['VideoRevision'];
    AbstractUuidConnection: ModelOf<AbstractUuidConnection>;
    AbstractUuidCursor: ModelOf<AbstractUuidCursor>;
    UuidMutation: ModelOf<UuidMutation>;
    UuidSetStateInput: ModelOf<UuidSetStateInput>;
    UuidSetStateResponse: ModelOf<UuidSetStateResponse>;
    AliasInput: ModelOf<AliasInput>;
    Applet: ModelOf<Applet>;
    AppletRevision: ModelOf<AppletRevision>;
    AppletRevisionConnection: ModelOf<AppletRevisionConnection>;
    AppletRevisionCursor: ModelOf<AppletRevisionCursor>;
    Article: ModelOf<Article>;
    ArticleRevision: ModelOf<ArticleRevision>;
    ArticleRevisionConnection: ModelOf<ArticleRevisionConnection>;
    ArticleRevisionCursor: ModelOf<ArticleRevisionCursor>;
    CoursePage: ModelOf<CoursePage>;
    CoursePageRevision: ModelOf<CoursePageRevision>;
    CoursePageRevisionConnection: ModelOf<CoursePageRevisionConnection>;
    CoursePageRevisionCursor: ModelOf<CoursePageRevisionCursor>;
    Course: ModelOf<Course>;
    CourseRevision: ModelOf<CourseRevision>;
    CourseRevisionConnection: ModelOf<CourseRevisionConnection>;
    CourseRevisionCursor: ModelOf<CourseRevisionCursor>;
    Event: ModelOf<Event_2>;
    EventRevision: ModelOf<EventRevision>;
    EventRevisionConnection: ModelOf<EventRevisionConnection>;
    EventRevisionCursor: ModelOf<EventRevisionCursor>;
    ExerciseGroup: ModelOf<ExerciseGroup>;
    ExerciseGroupRevision: ModelOf<ExerciseGroupRevision>;
    ExerciseGroupRevisionConnection: ModelOf<ExerciseGroupRevisionConnection>;
    ExerciseGroupRevisionCursor: ModelOf<ExerciseGroupRevisionCursor>;
    Exercise: ModelOf<Exercise>;
    ExerciseRevision: ModelOf<ExerciseRevision>;
    ExerciseRevisionConnection: ModelOf<ExerciseRevisionConnection>;
    ExerciseRevisionCursor: ModelOf<ExerciseRevisionCursor>;
    GroupedExercise: ModelOf<GroupedExercise>;
    GroupedExerciseRevision: ModelOf<GroupedExerciseRevision>;
    GroupedExerciseRevisionConnection: ModelOf<GroupedExerciseRevisionConnection>;
    GroupedExerciseRevisionCursor: ModelOf<GroupedExerciseRevisionCursor>;
    Page: ModelOf<Page>;
    PageRevision: ModelOf<PageRevision>;
    PageRevisionConnection: ModelOf<PageRevisionConnection>;
    PageRevisionCursor: ModelOf<PageRevisionCursor>;
    Solution: ModelOf<Solution>;
    SolutionRevision: ModelOf<SolutionRevision>;
    SolutionRevisionConnection: ModelOf<SolutionRevisionConnection>;
    SolutionRevisionCursor: ModelOf<SolutionRevisionCursor>;
    TaxonomyTerm: ModelOf<TaxonomyTerm>;
    User: ModelOf<User>;
    UserConnection: ModelOf<UserConnection>;
    UserEdge: ModelOf<UserEdge>;
    Video: ModelOf<Video>;
    VideoRevision: ModelOf<VideoRevision>;
    VideoRevisionConnection: ModelOf<VideoRevisionConnection>;
    VideoRevisionCursor: ModelOf<VideoRevisionCursor>;
};

// @public
export type ResolversTypes = {
    Query: ResolverTypeWrapper<{}>;
    String: ResolverTypeWrapper<ModelOf<Scalars['String']>>;
    Int: ResolverTypeWrapper<ModelOf<Scalars['Int']>>;
    Boolean: ResolverTypeWrapper<ModelOf<Scalars['Boolean']>>;
    Mutation: ResolverTypeWrapper<{}>;
    PageInfo: ResolverTypeWrapper<ModelOf<PageInfo>>;
    DateTime: ResolverTypeWrapper<ModelOf<Scalars['DateTime']>>;
    Instance: ResolverTypeWrapper<ModelOf<Instance>>;
    InstanceAware: ResolversTypes['CheckoutRevisionNotificationEvent'] | ResolversTypes['CreateCommentNotificationEvent'] | ResolversTypes['CreateEntityLinkNotificationEvent'] | ResolversTypes['CreateEntityNotificationEvent'] | ResolversTypes['CreateEntityRevisionNotificationEvent'] | ResolversTypes['CreateTaxonomyLinkNotificationEvent'] | ResolversTypes['CreateTaxonomyTermNotificationEvent'] | ResolversTypes['CreateThreadNotificationEvent'] | ResolversTypes['RejectRevisionNotificationEvent'] | ResolversTypes['RemoveEntityLinkNotificationEvent'] | ResolversTypes['RemoveTaxonomyLinkNotificationEvent'] | ResolversTypes['SetLicenseNotificationEvent'] | ResolversTypes['SetTaxonomyParentNotificationEvent'] | ResolversTypes['SetTaxonomyTermNotificationEvent'] | ResolversTypes['SetThreadStateNotificationEvent'] | ResolversTypes['SetUuidStateNotificationEvent'] | ResolversTypes['Applet'] | ResolversTypes['Article'] | ResolversTypes['CoursePage'] | ResolversTypes['Course'] | ResolversTypes['Event'] | ResolversTypes['ExerciseGroup'] | ResolversTypes['Exercise'] | ResolversTypes['GroupedExercise'] | ResolversTypes['Page'] | ResolversTypes['Solution'] | ResolversTypes['TaxonomyTerm'] | ResolversTypes['Video'];
    JSON: ResolverTypeWrapper<ModelOf<Scalars['JSON']>>;
    JSONObject: ResolverTypeWrapper<ModelOf<Scalars['JSONObject']>>;
    License: ResolverTypeWrapper<ModelOf<License>>;
    CheckoutRevisionNotificationEvent: ResolverTypeWrapper<ModelOf<CheckoutRevisionNotificationEvent>>;
    CreateCommentNotificationEvent: ResolverTypeWrapper<ModelOf<CreateCommentNotificationEvent>>;
    CreateEntityLinkNotificationEvent: ResolverTypeWrapper<ModelOf<CreateEntityLinkNotificationEvent>>;
    CreateEntityNotificationEvent: ResolverTypeWrapper<ModelOf<CreateEntityNotificationEvent>>;
    CreateEntityRevisionNotificationEvent: ResolverTypeWrapper<ModelOf<CreateEntityRevisionNotificationEvent>>;
    CreateTaxonomyLinkNotificationEvent: ResolverTypeWrapper<ModelOf<CreateTaxonomyLinkNotificationEvent>>;
    CreateTaxonomyTermNotificationEvent: ResolverTypeWrapper<ModelOf<CreateTaxonomyTermNotificationEvent>>;
    CreateThreadNotificationEvent: ResolverTypeWrapper<ModelOf<CreateThreadNotificationEvent>>;
    RejectRevisionNotificationEvent: ResolverTypeWrapper<ModelOf<RejectRevisionNotificationEvent>>;
    RemoveEntityLinkNotificationEvent: ResolverTypeWrapper<ModelOf<RemoveEntityLinkNotificationEvent>>;
    RemoveTaxonomyLinkNotificationEvent: ResolverTypeWrapper<ModelOf<RemoveTaxonomyLinkNotificationEvent>>;
    SetLicenseNotificationEvent: ResolverTypeWrapper<ModelOf<SetLicenseNotificationEvent>>;
    SetTaxonomyParentNotificationEvent: ResolverTypeWrapper<ModelOf<SetTaxonomyParentNotificationEvent>>;
    SetTaxonomyTermNotificationEvent: ResolverTypeWrapper<ModelOf<SetTaxonomyTermNotificationEvent>>;
    SetThreadStateNotificationEvent: ResolverTypeWrapper<ModelOf<SetThreadStateNotificationEvent>>;
    SetUuidStateNotificationEvent: ResolverTypeWrapper<ModelOf<SetUuidStateNotificationEvent>>;
    Notification: ResolverTypeWrapper<ModelOf<Notification_2>>;
    AbstractNotificationEvent: ResolversTypes['CheckoutRevisionNotificationEvent'] | ResolversTypes['CreateCommentNotificationEvent'] | ResolversTypes['CreateEntityLinkNotificationEvent'] | ResolversTypes['CreateEntityNotificationEvent'] | ResolversTypes['CreateEntityRevisionNotificationEvent'] | ResolversTypes['CreateTaxonomyLinkNotificationEvent'] | ResolversTypes['CreateTaxonomyTermNotificationEvent'] | ResolversTypes['CreateThreadNotificationEvent'] | ResolversTypes['RejectRevisionNotificationEvent'] | ResolversTypes['RemoveEntityLinkNotificationEvent'] | ResolversTypes['RemoveTaxonomyLinkNotificationEvent'] | ResolversTypes['SetLicenseNotificationEvent'] | ResolversTypes['SetTaxonomyParentNotificationEvent'] | ResolversTypes['SetTaxonomyTermNotificationEvent'] | ResolversTypes['SetThreadStateNotificationEvent'] | ResolversTypes['SetUuidStateNotificationEvent'];
    NotificationMutation: ResolverTypeWrapper<ModelOf<NotificationMutation>>;
    NotificationSetStateInput: ResolverTypeWrapper<ModelOf<NotificationSetStateInput>>;
    NotificationSetStateResponse: ResolverTypeWrapper<ModelOf<NotificationSetStateResponse>>;
    NotificationConnection: ResolverTypeWrapper<ModelOf<NotificationConnection>>;
    NotificationEdge: ResolverTypeWrapper<ModelOf<NotificationEdge>>;
    ScopedRole: ResolverTypeWrapper<ModelOf<ScopedRole>>;
    Role: ResolverTypeWrapper<ModelOf<Role>>;
    ScopedRoleConnection: ResolverTypeWrapper<ModelOf<ScopedRoleConnection>>;
    ScopedRoleCursor: ResolverTypeWrapper<ModelOf<ScopedRoleCursor>>;
    QuerySubscriptionResult: ResolverTypeWrapper<ModelOf<QuerySubscriptionResult>>;
    SubscriptionCursor: ResolverTypeWrapper<ModelOf<SubscriptionCursor>>;
    SubscriptionMutation: ResolverTypeWrapper<ModelOf<SubscriptionMutation>>;
    SubscriptionSetInput: ResolverTypeWrapper<ModelOf<SubscriptionSetInput>>;
    SubscriptionSetResponse: ResolverTypeWrapper<ModelOf<SubscriptionSetResponse>>;
    Thread: ResolverTypeWrapper<ModelOf<Thread>>;
    Comment: ResolverTypeWrapper<ModelOf<Comment>>;
    ThreadAware: ResolversTypes['Applet'] | ResolversTypes['AppletRevision'] | ResolversTypes['Article'] | ResolversTypes['ArticleRevision'] | ResolversTypes['CoursePage'] | ResolversTypes['CoursePageRevision'] | ResolversTypes['Course'] | ResolversTypes['CourseRevision'] | ResolversTypes['Event'] | ResolversTypes['EventRevision'] | ResolversTypes['ExerciseGroup'] | ResolversTypes['ExerciseGroupRevision'] | ResolversTypes['Exercise'] | ResolversTypes['ExerciseRevision'] | ResolversTypes['GroupedExercise'] | ResolversTypes['GroupedExerciseRevision'] | ResolversTypes['Page'] | ResolversTypes['PageRevision'] | ResolversTypes['Solution'] | ResolversTypes['SolutionRevision'] | ResolversTypes['TaxonomyTerm'] | ResolversTypes['User'] | ResolversTypes['Video'] | ResolversTypes['VideoRevision'];
    ThreadsConnection: ResolverTypeWrapper<ModelOf<ThreadsConnection>>;
    ThreadsCursor: ResolverTypeWrapper<ModelOf<ThreadsCursor>>;
    UnsupportedThread: ResolverTypeWrapper<ModelOf<UnsupportedThread>>;
    UnsupportedComment: ResolverTypeWrapper<ModelOf<UnsupportedComment>>;
    CommentConnection: ResolverTypeWrapper<ModelOf<CommentConnection>>;
    CommentEdge: ResolverTypeWrapper<ModelOf<CommentEdge>>;
    ThreadMutation: ResolverTypeWrapper<ModelOf<ThreadMutation>>;
    ThreadCreateThreadInput: ResolverTypeWrapper<ModelOf<ThreadCreateThreadInput>>;
    ThreadCreateThreadResponse: ResolverTypeWrapper<ModelOf<ThreadCreateThreadResponse>>;
    ThreadCreateCommentInput: ResolverTypeWrapper<ModelOf<ThreadCreateCommentInput>>;
    ThreadCreateCommentResponse: ResolverTypeWrapper<ModelOf<ThreadCreateCommentResponse>>;
    ThreadSetThreadArchivedInput: ResolverTypeWrapper<ModelOf<ThreadSetThreadArchivedInput>>;
    ThreadSetThreadArchivedResponse: ResolverTypeWrapper<ModelOf<ThreadSetThreadArchivedResponse>>;
    ThreadSetThreadStateInput: ResolverTypeWrapper<ModelOf<ThreadSetThreadStateInput>>;
    ThreadSetThreadStateResponse: ResolverTypeWrapper<ModelOf<ThreadSetThreadStateResponse>>;
    ThreadSetCommentStateInput: ResolverTypeWrapper<ModelOf<ThreadSetCommentStateInput>>;
    ThreadSetCommentStateResponse: ResolverTypeWrapper<ModelOf<ThreadSetCommentStateResponse>>;
    AbstractEntity: ResolversTypes['Applet'] | ResolversTypes['Article'] | ResolversTypes['CoursePage'] | ResolversTypes['Course'] | ResolversTypes['Event'] | ResolversTypes['ExerciseGroup'] | ResolversTypes['Exercise'] | ResolversTypes['GroupedExercise'] | ResolversTypes['Solution'] | ResolversTypes['Video'];
    AbstractEntityRevision: ResolversTypes['AppletRevision'] | ResolversTypes['ArticleRevision'] | ResolversTypes['CoursePageRevision'] | ResolversTypes['CourseRevision'] | ResolversTypes['EventRevision'] | ResolversTypes['ExerciseGroupRevision'] | ResolversTypes['ExerciseRevision'] | ResolversTypes['GroupedExerciseRevision'] | ResolversTypes['SolutionRevision'] | ResolversTypes['VideoRevision'];
    AbstractExercise: ResolversTypes['Exercise'] | ResolversTypes['GroupedExercise'];
    AbstractExerciseRevision: ResolversTypes['ExerciseRevision'] | ResolversTypes['GroupedExerciseRevision'];
    AbstractNavigationChild: ResolversTypes['Page'] | ResolversTypes['TaxonomyTerm'];
    Navigation: ResolverTypeWrapper<ModelOf<Navigation>>;
    NavigationNodeConnection: ResolverTypeWrapper<ModelOf<NavigationNodeConnection>>;
    NavigationNodeEdge: ResolverTypeWrapper<ModelOf<NavigationNodeEdge>>;
    NavigationNode: ResolverTypeWrapper<ModelOf<NavigationNode>>;
    AbstractRepository: ResolversTypes['Applet'] | ResolversTypes['Article'] | ResolversTypes['CoursePage'] | ResolversTypes['Course'] | ResolversTypes['Event'] | ResolversTypes['ExerciseGroup'] | ResolversTypes['Exercise'] | ResolversTypes['GroupedExercise'] | ResolversTypes['Page'] | ResolversTypes['Solution'] | ResolversTypes['Video'];
    AbstractRevision: ResolversTypes['AppletRevision'] | ResolversTypes['ArticleRevision'] | ResolversTypes['CoursePageRevision'] | ResolversTypes['CourseRevision'] | ResolversTypes['EventRevision'] | ResolversTypes['ExerciseGroupRevision'] | ResolversTypes['ExerciseRevision'] | ResolversTypes['GroupedExerciseRevision'] | ResolversTypes['PageRevision'] | ResolversTypes['SolutionRevision'] | ResolversTypes['VideoRevision'];
    AbstractTaxonomyTermChild: ResolversTypes['Applet'] | ResolversTypes['Article'] | ResolversTypes['Course'] | ResolversTypes['Event'] | ResolversTypes['ExerciseGroup'] | ResolversTypes['Exercise'] | ResolversTypes['Video'];
    TaxonomyTermConnection: ResolverTypeWrapper<ModelOf<TaxonomyTermConnection>>;
    TaxonomyTermEdge: ResolverTypeWrapper<ModelOf<TaxonomyTermEdge>>;
    AbstractUuid: ResolversTypes['Comment'] | ResolversTypes['Applet'] | ResolversTypes['AppletRevision'] | ResolversTypes['Article'] | ResolversTypes['ArticleRevision'] | ResolversTypes['CoursePage'] | ResolversTypes['CoursePageRevision'] | ResolversTypes['Course'] | ResolversTypes['CourseRevision'] | ResolversTypes['Event'] | ResolversTypes['EventRevision'] | ResolversTypes['ExerciseGroup'] | ResolversTypes['ExerciseGroupRevision'] | ResolversTypes['Exercise'] | ResolversTypes['ExerciseRevision'] | ResolversTypes['GroupedExercise'] | ResolversTypes['GroupedExerciseRevision'] | ResolversTypes['Page'] | ResolversTypes['PageRevision'] | ResolversTypes['Solution'] | ResolversTypes['SolutionRevision'] | ResolversTypes['TaxonomyTerm'] | ResolversTypes['User'] | ResolversTypes['Video'] | ResolversTypes['VideoRevision'];
    AbstractUuidConnection: ResolverTypeWrapper<ModelOf<AbstractUuidConnection>>;
    AbstractUuidCursor: ResolverTypeWrapper<ModelOf<AbstractUuidCursor>>;
    UuidMutation: ResolverTypeWrapper<ModelOf<UuidMutation>>;
    UuidSetStateInput: ResolverTypeWrapper<ModelOf<UuidSetStateInput>>;
    UuidSetStateResponse: ResolverTypeWrapper<ModelOf<UuidSetStateResponse>>;
    AliasInput: ResolverTypeWrapper<ModelOf<AliasInput>>;
    Applet: ResolverTypeWrapper<ModelOf<Applet>>;
    AppletRevision: ResolverTypeWrapper<ModelOf<AppletRevision>>;
    AppletRevisionConnection: ResolverTypeWrapper<ModelOf<AppletRevisionConnection>>;
    AppletRevisionCursor: ResolverTypeWrapper<ModelOf<AppletRevisionCursor>>;
    Article: ResolverTypeWrapper<ModelOf<Article>>;
    ArticleRevision: ResolverTypeWrapper<ModelOf<ArticleRevision>>;
    ArticleRevisionConnection: ResolverTypeWrapper<ModelOf<ArticleRevisionConnection>>;
    ArticleRevisionCursor: ResolverTypeWrapper<ModelOf<ArticleRevisionCursor>>;
    CoursePage: ResolverTypeWrapper<ModelOf<CoursePage>>;
    CoursePageRevision: ResolverTypeWrapper<ModelOf<CoursePageRevision>>;
    CoursePageRevisionConnection: ResolverTypeWrapper<ModelOf<CoursePageRevisionConnection>>;
    CoursePageRevisionCursor: ResolverTypeWrapper<ModelOf<CoursePageRevisionCursor>>;
    Course: ResolverTypeWrapper<ModelOf<Course>>;
    CourseRevision: ResolverTypeWrapper<ModelOf<CourseRevision>>;
    CourseRevisionConnection: ResolverTypeWrapper<ModelOf<CourseRevisionConnection>>;
    CourseRevisionCursor: ResolverTypeWrapper<ModelOf<CourseRevisionCursor>>;
    Event: ResolverTypeWrapper<ModelOf<Event_2>>;
    EventRevision: ResolverTypeWrapper<ModelOf<EventRevision>>;
    EventRevisionConnection: ResolverTypeWrapper<ModelOf<EventRevisionConnection>>;
    EventRevisionCursor: ResolverTypeWrapper<ModelOf<EventRevisionCursor>>;
    ExerciseGroup: ResolverTypeWrapper<ModelOf<ExerciseGroup>>;
    ExerciseGroupRevision: ResolverTypeWrapper<ModelOf<ExerciseGroupRevision>>;
    ExerciseGroupRevisionConnection: ResolverTypeWrapper<ModelOf<ExerciseGroupRevisionConnection>>;
    ExerciseGroupRevisionCursor: ResolverTypeWrapper<ModelOf<ExerciseGroupRevisionCursor>>;
    Exercise: ResolverTypeWrapper<ModelOf<Exercise>>;
    ExerciseRevision: ResolverTypeWrapper<ModelOf<ExerciseRevision>>;
    ExerciseRevisionConnection: ResolverTypeWrapper<ModelOf<ExerciseRevisionConnection>>;
    ExerciseRevisionCursor: ResolverTypeWrapper<ModelOf<ExerciseRevisionCursor>>;
    GroupedExercise: ResolverTypeWrapper<ModelOf<GroupedExercise>>;
    GroupedExerciseRevision: ResolverTypeWrapper<ModelOf<GroupedExerciseRevision>>;
    GroupedExerciseRevisionConnection: ResolverTypeWrapper<ModelOf<GroupedExerciseRevisionConnection>>;
    GroupedExerciseRevisionCursor: ResolverTypeWrapper<ModelOf<GroupedExerciseRevisionCursor>>;
    Page: ResolverTypeWrapper<ModelOf<Page>>;
    PageRevision: ResolverTypeWrapper<ModelOf<PageRevision>>;
    PageRevisionConnection: ResolverTypeWrapper<ModelOf<PageRevisionConnection>>;
    PageRevisionCursor: ResolverTypeWrapper<ModelOf<PageRevisionCursor>>;
    Solution: ResolverTypeWrapper<ModelOf<Solution>>;
    SolutionRevision: ResolverTypeWrapper<ModelOf<SolutionRevision>>;
    SolutionRevisionConnection: ResolverTypeWrapper<ModelOf<SolutionRevisionConnection>>;
    SolutionRevisionCursor: ResolverTypeWrapper<ModelOf<SolutionRevisionCursor>>;
    TaxonomyTermType: ResolverTypeWrapper<ModelOf<TaxonomyTermType>>;
    TaxonomyTerm: ResolverTypeWrapper<ModelOf<TaxonomyTerm>>;
    User: ResolverTypeWrapper<ModelOf<User>>;
    UserConnection: ResolverTypeWrapper<ModelOf<UserConnection>>;
    UserEdge: ResolverTypeWrapper<ModelOf<UserEdge>>;
    Video: ResolverTypeWrapper<ModelOf<Video>>;
    VideoRevision: ResolverTypeWrapper<ModelOf<VideoRevision>>;
    VideoRevisionConnection: ResolverTypeWrapper<ModelOf<VideoRevisionConnection>>;
    VideoRevisionCursor: ResolverTypeWrapper<ModelOf<VideoRevisionCursor>>;
};

// @public (undocumented)
export type ResolverTypeWrapper<T> = Promise<T> | T;

// @public (undocumented)
export type Revision<T extends Model<'AbstractRepository'>['__typename']> = Model<`${T}Revision`>;

// @public (undocumented)
export const RevisionDecoder: t.UnionC<[t.UnionC<[t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.AppletRevision>;
    url: t.StringC;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ArticleRevision>;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.CourseRevision>;
    title: t.StringC;
    content: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.CoursePageRevision>;
    title: t.StringC;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.EventRevision>;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ExerciseRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ExerciseGroupRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.GroupedExerciseRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.SolutionRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.VideoRevision>;
    url: t.StringC;
    title: t.StringC;
    content: t.StringC;
}>]>>]>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<DiscriminatorType.PageRevision>;
    title: t.StringC;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
}>]>>]>;

// @public (undocumented)
export type RevisionPayload = Model<'AbstractRevision'>;

// @public (undocumented)
export type RevisionType = EntityRevisionType | DiscriminatorType.PageRevision;

// @public (undocumented)
export enum Role {
    // (undocumented)
    Admin = "admin",
    // (undocumented)
    Architect = "architect",
    // (undocumented)
    Guest = "guest",
    // (undocumented)
    Login = "login",
    // (undocumented)
    Moderator = "moderator",
    // (undocumented)
    Reviewer = "reviewer",
    // (undocumented)
    StaticPagesBuilder = "staticPagesBuilder",
    // (undocumented)
    Sysadmin = "sysadmin"
}

// @public
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    DateTime: string;
    JSON: unknown;
    JSONObject: Record<string, unknown>;
};

// @public (undocumented)
export interface Schema {
    // (undocumented)
    resolvers: {};
    // (undocumented)
    typeDefs: DocumentNode[];
}

// @public (undocumented)
export type ScopedRole = {
    __typename?: 'ScopedRole';
    role: Role;
    scope?: Maybe<Scalars['String']>;
};

// @public (undocumented)
export type ScopedRoleConnection = {
    __typename?: 'ScopedRoleConnection';
    edges: Array<ScopedRoleCursor>;
    nodes: Array<ScopedRole>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type ScopedRoleConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ScopedRoleConnection'] = ResolversParentTypes['ScopedRoleConnection']> = {
    edges?: Resolver<Array<ResolversTypes['ScopedRoleCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['ScopedRole']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ScopedRoleCursor = {
    __typename?: 'ScopedRoleCursor';
    cursor: Scalars['String'];
    node: ScopedRole;
};

// @public (undocumented)
export type ScopedRoleCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ScopedRoleCursor'] = ResolversParentTypes['ScopedRoleCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['ScopedRole'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ScopedRoleResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ScopedRole'] = ResolversParentTypes['ScopedRole']> = {
    role?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
    scope?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export enum Service {
    // (undocumented)
    Serlo = "serlo.org",
    // (undocumented)
    SerloCloudflareWorker = "serlo.org-cloudflare-worker"
}

// @public (undocumented)
export type SetLicenseNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'SetLicenseNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    repository: Applet | Article | CoursePage | Course | Event_2 | ExerciseGroup | Exercise | GroupedExercise | Page | Solution | Video;
};

// @public (undocumented)
export const SetLicenseNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.SetLicense>;
    repositoryId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type SetLicenseNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SetLicenseNotificationEvent'] = ResolversParentTypes['SetLicenseNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['AbstractRepository'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type SetTaxonomyParentNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'SetTaxonomyParentNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    previousParent?: Maybe<TaxonomyTerm>;
    parent?: Maybe<TaxonomyTerm>;
    child: TaxonomyTerm;
};

// @public (undocumented)
export const SetTaxonomyParentNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.SetTaxonomyParent>;
    previousParentId: t.RefinementC<t.NumberC>;
    parentId: t.RefinementC<t.NumberC>;
    childId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type SetTaxonomyParentNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SetTaxonomyParentNotificationEvent'] = ResolversParentTypes['SetTaxonomyParentNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    previousParent?: Resolver<Maybe<ResolversTypes['TaxonomyTerm']>, ParentType, ContextType>;
    parent?: Resolver<Maybe<ResolversTypes['TaxonomyTerm']>, ParentType, ContextType>;
    child?: Resolver<ResolversTypes['TaxonomyTerm'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type SetTaxonomyTermNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'SetTaxonomyTermNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    taxonomyTerm: TaxonomyTerm;
};

// @public (undocumented)
export const SetTaxonomyTermNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.SetTaxonomyTerm>;
    taxonomyTermId: t.RefinementC<t.NumberC>;
}>]>>;

// @public (undocumented)
export type SetTaxonomyTermNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SetTaxonomyTermNotificationEvent'] = ResolversParentTypes['SetTaxonomyTermNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    taxonomyTerm?: Resolver<ResolversTypes['TaxonomyTerm'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type SetThreadStateNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'SetThreadStateNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    thread: UnsupportedThread;
    archived: Scalars['Boolean'];
};

// @public (undocumented)
export const SetThreadStateNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.SetThreadState>;
    threadId: t.RefinementC<t.NumberC>;
    archived: t.BooleanC;
}>]>>;

// @public (undocumented)
export type SetThreadStateNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SetThreadStateNotificationEvent'] = ResolversParentTypes['SetThreadStateNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    thread?: Resolver<ResolversTypes['UnsupportedThread'], ParentType, ContextType>;
    archived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type SetUuidStateNotificationEvent = AbstractNotificationEvent & InstanceAware & {
    __typename?: 'SetUuidStateNotificationEvent';
    id: Scalars['Int'];
    instance: Instance;
    date: Scalars['DateTime'];
    actor: User;
    objectId: Scalars['Int'];
    object: Comment | Applet | AppletRevision | Article | ArticleRevision | CoursePage | CoursePageRevision | Course | CourseRevision | Event_2 | EventRevision | ExerciseGroup | ExerciseGroupRevision | Exercise | ExerciseRevision | GroupedExercise | GroupedExerciseRevision | Page | PageRevision | Solution | SolutionRevision | TaxonomyTerm | User | Video | VideoRevision;
    trashed: Scalars['Boolean'];
};

// @public (undocumented)
export const SetUuidStateNotificationEventDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    actorId: t.RefinementC<t.NumberC>;
    objectId: t.RefinementC<t.NumberC>;
}>, t.TypeC<{
    __typename: t.LiteralC<NotificationEventType.SetUuidState>;
    trashed: t.BooleanC;
}>]>>;

// @public (undocumented)
export type SetUuidStateNotificationEventResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SetUuidStateNotificationEvent'] = ResolversParentTypes['SetUuidStateNotificationEvent']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    actor?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    objectId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    object?: Resolver<ResolversTypes['AbstractUuid'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type Solution = AbstractUuid & AbstractRepository & AbstractEntity & InstanceAware & ThreadAware & {
    __typename?: 'Solution';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    license: License;
    currentRevision?: Maybe<SolutionRevision>;
    revisions?: Maybe<SolutionRevisionConnection>;
    exercise: Exercise | GroupedExercise;
};

// @public (undocumented)
export const SolutionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Solution>;
    parentId: t.NumberC;
}>]>>;

// @public (undocumented)
export type SolutionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Solution'] = ResolversParentTypes['Solution']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<SolutionThreadsArgs, never>>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['SolutionRevision']>, ParentType, ContextType>;
    revisions?: Resolver<Maybe<ResolversTypes['SolutionRevisionConnection']>, ParentType, ContextType, RequireFields<SolutionRevisionsArgs, never>>;
    exercise?: Resolver<ResolversTypes['AbstractExercise'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type SolutionRevision = AbstractUuid & AbstractRevision & AbstractEntityRevision & ThreadAware & {
    __typename?: 'SolutionRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    repository: Solution;
    content: Scalars['String'];
    changes: Scalars['String'];
};

// @public (undocumented)
export type SolutionRevisionConnection = {
    __typename?: 'SolutionRevisionConnection';
    edges: Array<SolutionRevisionCursor>;
    nodes: Array<SolutionRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type SolutionRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SolutionRevisionConnection'] = ResolversParentTypes['SolutionRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['SolutionRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['SolutionRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type SolutionRevisionCursor = {
    __typename?: 'SolutionRevisionCursor';
    cursor: Scalars['String'];
    node: SolutionRevision;
};

// @public (undocumented)
export type SolutionRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SolutionRevisionCursor'] = ResolversParentTypes['SolutionRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['SolutionRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const SolutionRevisionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.SolutionRevision>;
    content: t.StringC;
}>]>>;

// @public (undocumented)
export type SolutionRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SolutionRevision'] = ResolversParentTypes['SolutionRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<SolutionRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['Solution'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type SolutionRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type SolutionRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type SolutionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;

// @public (undocumented)
export type SubscriptionCursor = {
    __typename?: 'SubscriptionCursor';
    cursor: Scalars['String'];
    node: Comment | Applet | AppletRevision | Article | ArticleRevision | CoursePage | CoursePageRevision | Course | CourseRevision | Event_2 | EventRevision | ExerciseGroup | ExerciseGroupRevision | Exercise | ExerciseRevision | GroupedExercise | GroupedExerciseRevision | Page | PageRevision | Solution | SolutionRevision | TaxonomyTerm | User | Video | VideoRevision;
};

// @public (undocumented)
export type SubscriptionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SubscriptionCursor'] = ResolversParentTypes['SubscriptionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['AbstractUuid'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type SubscriptionMutation = {
    __typename?: 'SubscriptionMutation';
    set?: Maybe<SubscriptionSetResponse>;
};

// @public (undocumented)
export type SubscriptionMutationResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SubscriptionMutation'] = ResolversParentTypes['SubscriptionMutation']> = {
    set?: Resolver<Maybe<ResolversTypes['SubscriptionSetResponse']>, ParentType, ContextType, RequireFields<SubscriptionMutationSetArgs, 'input'>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type SubscriptionMutationSetArgs = {
    input: SubscriptionSetInput;
};

// @public (undocumented)
export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> = SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs> | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

// @public (undocumented)
export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;

// @public (undocumented)
export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> = ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>) | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

// @public (undocumented)
export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    // (undocumented)
    resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
    // (undocumented)
    subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
}

// @public (undocumented)
export type SubscriptionSetInput = {
    id: Array<Scalars['Int']>;
    subscribe: Scalars['Boolean'];
    sendEmail: Scalars['Boolean'];
};

// @public (undocumented)
export type SubscriptionSetResponse = {
    __typename?: 'SubscriptionSetResponse';
    success: Scalars['Boolean'];
    query: Query;
};

// @public (undocumented)
export type SubscriptionSetResponseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['SubscriptionSetResponse'] = ResolversParentTypes['SubscriptionSetResponse']> = {
    success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export interface SubscriptionsPayload {
    // (undocumented)
    subscriptions: {
        id: number;
    }[];
    // (undocumented)
    userId: number;
}

// @public (undocumented)
export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

// @public (undocumented)
export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
    // (undocumented)
    resolve?: SubscriptionResolveFn<TResult, {
        [key in TKey]: TResult;
    }, TContext, TArgs>;
    // (undocumented)
    subscribe: SubscriptionSubscribeFn<{
        [key in TKey]: TResult;
    }, TParent, TContext, TArgs>;
}

// @public (undocumented)
export interface SwrQueue {
    // (undocumented)
    healthy(): Promise<void>;
    // (undocumented)
    queue(updateJob: UpdateJob): Promise<never>;
    // (undocumented)
    _queue: never;
    // (undocumented)
    quit(): Promise<void>;
    // (undocumented)
    ready(): Promise<void>;
}

// @public (undocumented)
export type TaxonomyTerm = AbstractUuid & AbstractNavigationChild & InstanceAware & ThreadAware & {
    __typename?: 'TaxonomyTerm';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    type: TaxonomyTermType;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    name: Scalars['String'];
    description?: Maybe<Scalars['String']>;
    weight: Scalars['Int'];
    parent?: Maybe<TaxonomyTerm>;
    children: AbstractUuidConnection;
    navigation?: Maybe<Navigation>;
};

// @public (undocumented)
export type TaxonomyTermChildrenArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type TaxonomyTermConnection = {
    __typename?: 'TaxonomyTermConnection';
    edges?: Maybe<Array<Maybe<TaxonomyTermEdge>>>;
    nodes: Array<TaxonomyTerm>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type TaxonomyTermConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['TaxonomyTermConnection'] = ResolversParentTypes['TaxonomyTermConnection']> = {
    edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaxonomyTermEdge']>>>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['TaxonomyTerm']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const TaxonomyTermDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<DiscriminatorType.TaxonomyTerm>;
    type: t.UnionC<[t.LiteralC<TaxonomyTermType.Blog>, t.LiteralC<TaxonomyTermType.Curriculum>, t.LiteralC<TaxonomyTermType.CurriculumTopic>, t.LiteralC<TaxonomyTermType.CurriculumTopicFolder>, t.LiteralC<TaxonomyTermType.Forum>, t.LiteralC<TaxonomyTermType.ForumCategory>, t.LiteralC<TaxonomyTermType.Locale>, t.LiteralC<TaxonomyTermType.Root>, t.LiteralC<TaxonomyTermType.Subject>, t.LiteralC<TaxonomyTermType.Topic>, t.LiteralC<TaxonomyTermType.TopicFolder>]>;
    instance: t.Type<Instance, Instance, unknown>;
    name: t.StringC;
    weight: t.NumberC;
    childrenIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    parentId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>, t.PartialC<{
    description: t.UnionC<[t.StringC, t.NullC]>;
}>]>>;

// @public (undocumented)
export type TaxonomyTermEdge = {
    __typename?: 'TaxonomyTermEdge';
    cursor: Scalars['String'];
    node: TaxonomyTerm;
};

// @public (undocumented)
export type TaxonomyTermEdgeResolvers<ContextType = Context, ParentType extends ResolversParentTypes['TaxonomyTermEdge'] = ResolversParentTypes['TaxonomyTermEdge']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['TaxonomyTerm'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type TaxonomyTermPayload = t_2.TypeOf<typeof TaxonomyTermDecoder>;

// @public (undocumented)
export type TaxonomyTermResolvers<ContextType = Context, ParentType extends ResolversParentTypes['TaxonomyTerm'] = ResolversParentTypes['TaxonomyTerm']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<TaxonomyTermThreadsArgs, never>>;
    type?: Resolver<ResolversTypes['TaxonomyTermType'], ParentType, ContextType>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    weight?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    parent?: Resolver<Maybe<ResolversTypes['TaxonomyTerm']>, ParentType, ContextType>;
    children?: Resolver<ResolversTypes['AbstractUuidConnection'], ParentType, ContextType, RequireFields<TaxonomyTermChildrenArgs, never>>;
    navigation?: Resolver<Maybe<ResolversTypes['Navigation']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type TaxonomyTermThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export enum TaxonomyTermType {
    // (undocumented)
    Blog = "blog",
    // (undocumented)
    Curriculum = "curriculum",
    // (undocumented)
    CurriculumTopic = "curriculumTopic",
    // (undocumented)
    CurriculumTopicFolder = "curriculumTopicFolder",
    // (undocumented)
    Forum = "forum",
    // (undocumented)
    ForumCategory = "forumCategory",
    // (undocumented)
    Locale = "locale",
    // (undocumented)
    Root = "root",
    // (undocumented)
    Subject = "subject",
    // (undocumented)
    Topic = "topic",
    // (undocumented)
    TopicFolder = "topicFolder"
}

// @public (undocumented)
export const TaxonomyTermTypeDecoder: t.UnionC<[t.LiteralC<TaxonomyTermType.Blog>, t.LiteralC<TaxonomyTermType.Curriculum>, t.LiteralC<TaxonomyTermType.CurriculumTopic>, t.LiteralC<TaxonomyTermType.CurriculumTopicFolder>, t.LiteralC<TaxonomyTermType.Forum>, t.LiteralC<TaxonomyTermType.ForumCategory>, t.LiteralC<TaxonomyTermType.Locale>, t.LiteralC<TaxonomyTermType.Root>, t.LiteralC<TaxonomyTermType.Subject>, t.LiteralC<TaxonomyTermType.Topic>, t.LiteralC<TaxonomyTermType.TopicFolder>]>;

// @public (undocumented)
export type Thread = {
    __typename?: 'Thread';
    id: Scalars['String'];
    createdAt: Scalars['DateTime'];
    title?: Maybe<Scalars['String']>;
    archived: Scalars['Boolean'];
    object: Comment | Applet | AppletRevision | Article | ArticleRevision | CoursePage | CoursePageRevision | Course | CourseRevision | Event_2 | EventRevision | ExerciseGroup | ExerciseGroupRevision | Exercise | ExerciseRevision | GroupedExercise | GroupedExerciseRevision | Page | PageRevision | Solution | SolutionRevision | TaxonomyTerm | User | Video | VideoRevision;
    comments: CommentConnection;
};

// @public (undocumented)
export type ThreadAware = {
    threads: ThreadsConnection;
};

// @public (undocumented)
export type ThreadAwareResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ThreadAware'] = ResolversParentTypes['ThreadAware']> = {
    __resolveType: TypeResolveFn<'Applet' | 'AppletRevision' | 'Article' | 'ArticleRevision' | 'CoursePage' | 'CoursePageRevision' | 'Course' | 'CourseRevision' | 'Event' | 'EventRevision' | 'ExerciseGroup' | 'ExerciseGroupRevision' | 'Exercise' | 'ExerciseRevision' | 'GroupedExercise' | 'GroupedExerciseRevision' | 'Page' | 'PageRevision' | 'Solution' | 'SolutionRevision' | 'TaxonomyTerm' | 'User' | 'Video' | 'VideoRevision', ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<ThreadAwareThreadsArgs, never>>;
};

// @public (undocumented)
export type ThreadAwareThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type ThreadCommentsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type ThreadCreateCommentInput = {
    content: Scalars['String'];
    threadId: Scalars['String'];
    subscribe: Scalars['Boolean'];
    sendEmail: Scalars['Boolean'];
};

// @public (undocumented)
export type ThreadCreateCommentResponse = {
    __typename?: 'ThreadCreateCommentResponse';
    record?: Maybe<Comment>;
    success: Scalars['Boolean'];
    query: Query;
};

// @public (undocumented)
export type ThreadCreateCommentResponseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ThreadCreateCommentResponse'] = ResolversParentTypes['ThreadCreateCommentResponse']> = {
    record?: Resolver<Maybe<ResolversTypes['Comment']>, ParentType, ContextType>;
    success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ThreadCreateThreadInput = {
    title: Scalars['String'];
    content: Scalars['String'];
    objectId: Scalars['Int'];
    subscribe: Scalars['Boolean'];
    sendEmail: Scalars['Boolean'];
};

// @public (undocumented)
export type ThreadCreateThreadResponse = {
    __typename?: 'ThreadCreateThreadResponse';
    record?: Maybe<Thread>;
    success: Scalars['Boolean'];
    query: Query;
};

// @public (undocumented)
export type ThreadCreateThreadResponseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ThreadCreateThreadResponse'] = ResolversParentTypes['ThreadCreateThreadResponse']> = {
    record?: Resolver<Maybe<ResolversTypes['Thread']>, ParentType, ContextType>;
    success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ThreadMutation = {
    __typename?: 'ThreadMutation';
    createThread?: Maybe<ThreadCreateThreadResponse>;
    createComment?: Maybe<ThreadCreateCommentResponse>;
    setThreadArchived?: Maybe<ThreadSetThreadArchivedResponse>;
    setThreadState?: Maybe<ThreadSetThreadStateResponse>;
    setCommentState?: Maybe<ThreadSetCommentStateResponse>;
};

// @public (undocumented)
export type ThreadMutationCreateCommentArgs = {
    input: ThreadCreateCommentInput;
};

// @public (undocumented)
export type ThreadMutationCreateThreadArgs = {
    input: ThreadCreateThreadInput;
};

// @public (undocumented)
export type ThreadMutationResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ThreadMutation'] = ResolversParentTypes['ThreadMutation']> = {
    createThread?: Resolver<Maybe<ResolversTypes['ThreadCreateThreadResponse']>, ParentType, ContextType, RequireFields<ThreadMutationCreateThreadArgs, 'input'>>;
    createComment?: Resolver<Maybe<ResolversTypes['ThreadCreateCommentResponse']>, ParentType, ContextType, RequireFields<ThreadMutationCreateCommentArgs, 'input'>>;
    setThreadArchived?: Resolver<Maybe<ResolversTypes['ThreadSetThreadArchivedResponse']>, ParentType, ContextType, RequireFields<ThreadMutationSetThreadArchivedArgs, 'input'>>;
    setThreadState?: Resolver<Maybe<ResolversTypes['ThreadSetThreadStateResponse']>, ParentType, ContextType, RequireFields<ThreadMutationSetThreadStateArgs, 'input'>>;
    setCommentState?: Resolver<Maybe<ResolversTypes['ThreadSetCommentStateResponse']>, ParentType, ContextType, RequireFields<ThreadMutationSetCommentStateArgs, 'input'>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ThreadMutationSetCommentStateArgs = {
    input: ThreadSetCommentStateInput;
};

// @public (undocumented)
export type ThreadMutationSetThreadArchivedArgs = {
    input: ThreadSetThreadArchivedInput;
};

// @public (undocumented)
export type ThreadMutationSetThreadStateArgs = {
    input: ThreadSetThreadStateInput;
};

// @public (undocumented)
export type ThreadResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Thread'] = ResolversParentTypes['Thread']> = {
    id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    archived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    object?: Resolver<ResolversTypes['AbstractUuid'], ParentType, ContextType>;
    comments?: Resolver<ResolversTypes['CommentConnection'], ParentType, ContextType, RequireFields<ThreadCommentsArgs, never>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ThreadsConnection = {
    __typename?: 'ThreadsConnection';
    edges: Array<ThreadsCursor>;
    nodes: Array<Thread>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type ThreadsConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ThreadsConnection'] = ResolversParentTypes['ThreadsConnection']> = {
    edges?: Resolver<Array<ResolversTypes['ThreadsCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['Thread']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ThreadsCursor = {
    __typename?: 'ThreadsCursor';
    cursor: Scalars['String'];
    node: Thread;
};

// @public (undocumented)
export type ThreadsCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ThreadsCursor'] = ResolversParentTypes['ThreadsCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['Thread'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ThreadSetCommentStateInput = {
    id: Array<Scalars['Int']>;
    trashed: Scalars['Boolean'];
};

// @public (undocumented)
export type ThreadSetCommentStateResponse = {
    __typename?: 'ThreadSetCommentStateResponse';
    success: Scalars['Boolean'];
    query: Query;
};

// @public (undocumented)
export type ThreadSetCommentStateResponseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ThreadSetCommentStateResponse'] = ResolversParentTypes['ThreadSetCommentStateResponse']> = {
    success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ThreadSetThreadArchivedInput = {
    id: Array<Scalars['String']>;
    archived: Scalars['Boolean'];
};

// @public (undocumented)
export type ThreadSetThreadArchivedResponse = {
    __typename?: 'ThreadSetThreadArchivedResponse';
    success: Scalars['Boolean'];
    query: Query;
};

// @public (undocumented)
export type ThreadSetThreadArchivedResponseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ThreadSetThreadArchivedResponse'] = ResolversParentTypes['ThreadSetThreadArchivedResponse']> = {
    success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type ThreadSetThreadStateInput = {
    id: Array<Scalars['String']>;
    trashed: Scalars['Boolean'];
};

// @public (undocumented)
export type ThreadSetThreadStateResponse = {
    __typename?: 'ThreadSetThreadStateResponse';
    success: Scalars['Boolean'];
    query: Query;
};

// @public (undocumented)
export type ThreadSetThreadStateResponseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['ThreadSetThreadStateResponse'] = ResolversParentTypes['ThreadSetThreadStateResponse']> = {
    success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export interface Time {
    // (undocumented)
    day?: number;
    // (undocumented)
    days?: number;
    // (undocumented)
    hour?: number;
    // (undocumented)
    hours?: number;
    // (undocumented)
    minute?: number;
    // (undocumented)
    minutes?: number;
    // (undocumented)
    second?: number;
    // (undocumented)
    seconds?: number;
}

// @public (undocumented)
export interface Timer {
    // (undocumented)
    now: typeof Date.now;
}

// @public (undocumented)
export function timeToMilliseconds({ day, days, hour, hours, minute, minutes, second, seconds, }: Time): number;

// @public (undocumented)
export type Typename<T> = T extends {
    __typename?: infer U;
} ? U extends string ? U : never : never;

// @public (undocumented)
export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (parent: TParent, context: TContext, info: GraphQLResolveInfo) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

// @public (undocumented)
export type TypeResolver<T> = (type: T) => string;

// @public
export type TypeResolvers<T extends {
    __typename?: keyof Resolvers;
}> = Typename<T> extends keyof Resolvers ? A.Compute<O.MergeUp<RequiredResolvers<T>, Pick<Resolvers, Typename<T>>, 'deep'>, 'deep'> : never;

// @public (undocumented)
export type UnsupportedComment = {
    __typename?: 'UnsupportedComment';
    id: Scalars['Int'];
};

// @public (undocumented)
export type UnsupportedCommentResolvers<ContextType = Context, ParentType extends ResolversParentTypes['UnsupportedComment'] = ResolversParentTypes['UnsupportedComment']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type UnsupportedThread = {
    __typename?: 'UnsupportedThread';
    id: Scalars['Int'];
};

// @public (undocumented)
export type UnsupportedThreadResolvers<ContextType = Context, ParentType extends ResolversParentTypes['UnsupportedThread'] = ResolversParentTypes['UnsupportedThread']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export interface UpdateFunction<T> {
    // (undocumented)
    getValue: (current?: T) => AsyncOrSync<T | undefined>;
}

// @public (undocumented)
export interface UpdateJob {
    // (undocumented)
    key: string;
}

// @public (undocumented)
export type User = AbstractUuid & ThreadAware & {
    __typename?: 'User';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    alias?: Maybe<Scalars['String']>;
    username: Scalars['String'];
    date: Scalars['DateTime'];
    lastLogin?: Maybe<Scalars['DateTime']>;
    roles: ScopedRoleConnection;
    description?: Maybe<Scalars['String']>;
    activeAuthor: Scalars['Boolean'];
    activeDonor: Scalars['Boolean'];
    activeReviewer: Scalars['Boolean'];
};

// @public (undocumented)
export type UserConnection = {
    __typename?: 'UserConnection';
    edges: Array<UserEdge>;
    nodes: Array<User>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type UserConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['UserConnection'] = ResolversParentTypes['UserConnection']> = {
    edges?: Resolver<Array<ResolversTypes['UserEdge']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['User']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const UserDecoder: t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<DiscriminatorType.User>;
    username: t.StringC;
    date: t.StringC;
    roles: t.ArrayC<t.StringC>;
}>, t.PartialC<{
    lastLogin: t.UnionC<[t.StringC, t.NullC]>;
    description: t.UnionC<[t.StringC, t.NullC]>;
}>]>>;

// @public (undocumented)
export type UserEdge = {
    __typename?: 'UserEdge';
    cursor: Scalars['String'];
    node: User;
};

// @public (undocumented)
export type UserEdgeResolvers<ContextType = Context, ParentType extends ResolversParentTypes['UserEdge'] = ResolversParentTypes['UserEdge']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type UserResolvers<ContextType = Context, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<UserThreadsArgs, never>>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    username?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    lastLogin?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
    roles?: Resolver<ResolversTypes['ScopedRoleConnection'], ParentType, ContextType, RequireFields<UserRolesArgs, never>>;
    description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    activeAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    activeDonor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    activeReviewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type UserRolesArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type UserThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export const Uuid: t.RefinementC<t.NumberC>;

// @public (undocumented)
export const UuidDecoder: t.UnionC<[t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<"Comment">;
    authorId: t.NumberC;
    title: t.UnionC<[t.StringC, t.NullC]>;
    date: t.StringC;
    archived: t.BooleanC;
    content: t.StringC;
    parentId: t.RefinementC<t.NumberC>;
    childrenIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.UnionC<[t.UnionC<[t.UnionC<[t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Exercise>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    solutionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.GroupedExercise>;
    parentId: t.RefinementC<t.NumberC>;
    solutionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>]>>]>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Applet>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Article>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Course>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    pageIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.CoursePage>;
    parentId: t.RefinementC<t.NumberC>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Event>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.ExerciseGroup>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    exerciseIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Solution>;
    parentId: t.NumberC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Video>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>]>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<DiscriminatorType.Page>;
    instance: t.Type<Instance, Instance, unknown>;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    date: t.StringC;
    licenseId: t.NumberC;
}>]>>]>, t.UnionC<[t.UnionC<[t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.AppletRevision>;
    url: t.StringC;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ArticleRevision>;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.CourseRevision>;
    title: t.StringC;
    content: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.CoursePageRevision>;
    title: t.StringC;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.EventRevision>;
    title: t.StringC;
    content: t.StringC;
    metaTitle: t.StringC;
    metaDescription: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ExerciseRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.ExerciseGroupRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.GroupedExerciseRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.SolutionRevision>;
    content: t.StringC;
}>]>>, t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.VideoRevision>;
    url: t.StringC;
    title: t.StringC;
    content: t.StringC;
}>]>>]>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<DiscriminatorType.PageRevision>;
    title: t.StringC;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
}>]>>]>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<DiscriminatorType.TaxonomyTerm>;
    type: t.UnionC<[t.LiteralC<TaxonomyTermType.Blog>, t.LiteralC<TaxonomyTermType.Curriculum>, t.LiteralC<TaxonomyTermType.CurriculumTopic>, t.LiteralC<TaxonomyTermType.CurriculumTopicFolder>, t.LiteralC<TaxonomyTermType.Forum>, t.LiteralC<TaxonomyTermType.ForumCategory>, t.LiteralC<TaxonomyTermType.Locale>, t.LiteralC<TaxonomyTermType.Root>, t.LiteralC<TaxonomyTermType.Subject>, t.LiteralC<TaxonomyTermType.Topic>, t.LiteralC<TaxonomyTermType.TopicFolder>]>;
    instance: t.Type<Instance, Instance, unknown>;
    name: t.StringC;
    weight: t.NumberC;
    childrenIds: t.ArrayC<t.RefinementC<t.NumberC>>;
    parentId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
}>, t.PartialC<{
    description: t.UnionC<[t.StringC, t.NullC]>;
}>]>>, t.ExactC<t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.LiteralC<DiscriminatorType.User>;
    username: t.StringC;
    date: t.StringC;
    roles: t.ArrayC<t.StringC>;
}>, t.PartialC<{
    lastLogin: t.UnionC<[t.StringC, t.NullC]>;
    description: t.UnionC<[t.StringC, t.NullC]>;
}>]>>]>;

// @public (undocumented)
export type UuidMutation = {
    __typename?: 'UuidMutation';
    setState?: Maybe<UuidSetStateResponse>;
};

// @public (undocumented)
export type UuidMutationResolvers<ContextType = Context, ParentType extends ResolversParentTypes['UuidMutation'] = ResolversParentTypes['UuidMutation']> = {
    setState?: Resolver<Maybe<ResolversTypes['UuidSetStateResponse']>, ParentType, ContextType, RequireFields<UuidMutationSetStateArgs, 'input'>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type UuidMutationSetStateArgs = {
    input: UuidSetStateInput;
};

// @public (undocumented)
export type UuidPayload = Model<'AbstractUuid'>;

// @public (undocumented)
export type UuidSetStateInput = {
    id: Array<Scalars['Int']>;
    trashed: Scalars['Boolean'];
};

// @public (undocumented)
export type UuidSetStateResponse = {
    __typename?: 'UuidSetStateResponse';
    success: Scalars['Boolean'];
    query: Query;
};

// @public (undocumented)
export type UuidSetStateResponseResolvers<ContextType = Context, ParentType extends ResolversParentTypes['UuidSetStateResponse'] = ResolversParentTypes['UuidSetStateResponse']> = {
    success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type UuidType = DiscriminatorType | EntityType | EntityRevisionType;

// @public (undocumented)
export type Video = AbstractUuid & AbstractRepository & AbstractEntity & AbstractTaxonomyTermChild & InstanceAware & ThreadAware & {
    __typename?: 'Video';
    id: Scalars['Int'];
    trashed: Scalars['Boolean'];
    threads: ThreadsConnection;
    instance: Instance;
    alias?: Maybe<Scalars['String']>;
    date: Scalars['DateTime'];
    license: License;
    currentRevision?: Maybe<VideoRevision>;
    revisions: VideoRevisionConnection;
    taxonomyTerms: TaxonomyTermConnection;
};

// @public (undocumented)
export const VideoDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityType.Applet>, t.LiteralC<EntityType.Article>, t.LiteralC<EntityType.Course>, t.LiteralC<EntityType.CoursePage>, t.LiteralC<EntityType.Event>, t.LiteralC<EntityType.Exercise>, t.LiteralC<EntityType.ExerciseGroup>, t.LiteralC<EntityType.GroupedExercise>, t.LiteralC<EntityType.Solution>, t.LiteralC<EntityType.Video>]>;
    instance: t.Type<Instance, Instance, unknown>;
    date: t.StringC;
    licenseId: t.NumberC;
    currentRevisionId: t.UnionC<[t.RefinementC<t.NumberC>, t.NullC]>;
    revisionIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityType.Video>;
    taxonomyTermIds: t.ArrayC<t.RefinementC<t.NumberC>>;
}>]>>;

// @public (undocumented)
export type VideoResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Video'] = ResolversParentTypes['Video']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<VideoThreadsArgs, never>>;
    instance?: Resolver<ResolversTypes['Instance'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    license?: Resolver<ResolversTypes['License'], ParentType, ContextType>;
    currentRevision?: Resolver<Maybe<ResolversTypes['VideoRevision']>, ParentType, ContextType>;
    revisions?: Resolver<ResolversTypes['VideoRevisionConnection'], ParentType, ContextType, RequireFields<VideoRevisionsArgs, never>>;
    taxonomyTerms?: Resolver<ResolversTypes['TaxonomyTermConnection'], ParentType, ContextType, RequireFields<VideoTaxonomyTermsArgs, never>>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type VideoRevision = AbstractUuid & AbstractRevision & AbstractEntityRevision & ThreadAware & {
    __typename?: 'VideoRevision';
    id: Scalars['Int'];
    author: User;
    trashed: Scalars['Boolean'];
    alias?: Maybe<Scalars['String']>;
    threads: ThreadsConnection;
    date: Scalars['DateTime'];
    repository: Video;
    url: Scalars['String'];
    title: Scalars['String'];
    content: Scalars['String'];
    changes: Scalars['String'];
};

// @public (undocumented)
export type VideoRevisionConnection = {
    __typename?: 'VideoRevisionConnection';
    edges: Array<VideoRevisionCursor>;
    nodes: Array<VideoRevision>;
    totalCount: Scalars['Int'];
    pageInfo: PageInfo;
};

// @public (undocumented)
export type VideoRevisionConnectionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['VideoRevisionConnection'] = ResolversParentTypes['VideoRevisionConnection']> = {
    edges?: Resolver<Array<ResolversTypes['VideoRevisionCursor']>, ParentType, ContextType>;
    nodes?: Resolver<Array<ResolversTypes['VideoRevision']>, ParentType, ContextType>;
    totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type VideoRevisionCursor = {
    __typename?: 'VideoRevisionCursor';
    cursor: Scalars['String'];
    node: VideoRevision;
};

// @public (undocumented)
export type VideoRevisionCursorResolvers<ContextType = Context, ParentType extends ResolversParentTypes['VideoRevisionCursor'] = ResolversParentTypes['VideoRevisionCursor']> = {
    cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    node?: Resolver<ResolversTypes['VideoRevision'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export const VideoRevisionDecoder: t.ExactC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    id: t.RefinementC<t.NumberC>;
    trashed: t.BooleanC;
    alias: t.RefinementC<t.StringC>;
}>, t.TypeC<{
    __typename: t.UnionC<[t.LiteralC<EntityRevisionType.AppletRevision>, t.LiteralC<EntityRevisionType.ArticleRevision>, t.LiteralC<EntityRevisionType.CourseRevision>, t.LiteralC<EntityRevisionType.CoursePageRevision>, t.LiteralC<EntityRevisionType.EventRevision>, t.LiteralC<EntityRevisionType.ExerciseRevision>, t.LiteralC<EntityRevisionType.ExerciseGroupRevision>, t.LiteralC<EntityRevisionType.GroupedExerciseRevision>, t.LiteralC<EntityRevisionType.SolutionRevision>, t.LiteralC<EntityRevisionType.VideoRevision>]>;
    content: t.StringC;
    date: t.StringC;
    authorId: t.RefinementC<t.NumberC>;
    repositoryId: t.RefinementC<t.NumberC>;
    changes: t.StringC;
}>]>, t.TypeC<{
    __typename: t.LiteralC<EntityRevisionType.VideoRevision>;
    url: t.StringC;
    title: t.StringC;
    content: t.StringC;
}>]>>;

// @public (undocumented)
export type VideoRevisionResolvers<ContextType = Context, ParentType extends ResolversParentTypes['VideoRevision'] = ResolversParentTypes['VideoRevision']> = {
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    trashed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    alias?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    threads?: Resolver<ResolversTypes['ThreadsConnection'], ParentType, ContextType, RequireFields<VideoRevisionThreadsArgs, never>>;
    date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    repository?: Resolver<ResolversTypes['Video'], ParentType, ContextType>;
    url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    changes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

// @public (undocumented)
export type VideoRevisionsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    unrevised?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type VideoRevisionThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};

// @public (undocumented)
export type VideoTaxonomyTermsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
};

// @public (undocumented)
export type VideoThreadsArgs = {
    after?: Maybe<Scalars['String']>;
    before?: Maybe<Scalars['String']>;
    first?: Maybe<Scalars['Int']>;
    last?: Maybe<Scalars['Int']>;
    archived?: Maybe<Scalars['Boolean']>;
    trashed?: Maybe<Scalars['Boolean']>;
};


// Warnings were encountered during analysis:
//
// dist/model/types.d.ts:80:9 - (ae-forgotten-export) The symbol "Scope" needs to be exported by the entry point api.d.ts

// (No @packageDocumentation comment for this package)

```
